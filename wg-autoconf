#!/usr/bin/env bash

# note: Origin of default prefix: Wireguard = 'w' = [119] = [0x77] = fd77:: (fd/8 is required as a private/local IPv6-range prefix)
# note: The server exposes a TCP-socket at the same port as as wireguard (which is listening to UDP), due to the different protocol, these ports are not in conflict
# note: The wg-autoconf non-standard configuration is stored in /etc/wireguard/<interface>.autoconf, the derived configuration for Wireguard is in /etc/wireguard/<interface>.conf
# note: It is highly recommended to change the Wireguard port from 51820 to a non-ephemeral port, since another process may already use this port, which results in a higher chance of conflict. For example, use port 5182 or 5177 instead, or fd77.
# note: Wireguard is dual-stack by default.
# note: The virtual IPv6-address consists of: <16bit PREFIX>:<16bit GROUP>:<16bit SUBNET>:<16bit RESERVED>:<64bit INTERFACE_ID>


# TODO: make separate wg utility that enables easy setup for MASQUERADE VPN usage (which does ipv4/ipv6 dual stack configuration)

# default port as per Wireguard docs
WIREGUARD_PORT="51820"

# timeout for socket connections, where we're waiting for data
PROTOCOL_TIMEOUT_S="20"

# set default metric for this Wireguard interface
DEFAULT_METRIC="1024"

# higher MTU is better for performance, MTU is min 1280, and typically max 1500, Wireguard UDP header needs 80 bytes so 1420 would be suggested, if MTU is too high, all or some packets may drop, 1400 is a more safe value
# (tested: MTU 1400 does not work via EWON router, but 1300 does)
DEFAULT_MTU="1280"

# Sensible default values:
DEFAULT_VPN_PREFIX="fd77:1"
DEFAULT_VPN_ADDRESS="$DEFAULT_VPN_PREFIX::1/48" # 48 is the subnet mask of this interface
DEFAULT_VPN_PREFIX_MASK="32" # unique prefix mask for routing (to have one route for multiple not yet known subnets/servers)

DEFAULT_BIND_HOST="::"
DEFAULT_PERSISTENT_KEEPALIVE_S="25"

# by convention, it's good to route prefix fd77:X to wgX, where X >= 1
# X could be a base36 (alphanumeric) encoded identifier of basically three digits/characters long identifying the group
# 'wrg', short for 'wireguard', would become 42460 (= parseInt('wrg', 36)), to hexadecimal that is: 'a5dc' (= (42460).toString(16))
# so the unique prefix becomes: fd77:a5dc

expand_ipv6()
{
	__expand_ipv6_ip="${1%%/*}"
	__expand_ipv6_mask=""

	# extract and filter mask at end of address
	case "$1" in
		*/*)
			__expand_ipv6_mask="${1#*/}"
			__expand_ipv6_mask="/${__expand_ipv6_mask%%[^0-9/]*}"
	esac

	case "$__expand_ipv6_ip" in
		:*) __expand_ipv6_ip="0$__expand_ipv6_ip"
	esac

	case "$__expand_ipv6_ip" in
		*::*)
			__expand_ipv6_colons="$(tr -c -d ':' <<<"$__expand_ipv6_ip")"
			__expand_ipv6_expanded="$(echo ":::::::::" | sed -e "s/$__expand_ipv6_colons//" -e 's/:/:0/g')"
			__expand_ipv6_ip="$(echo "$__expand_ipv6_ip" | sed "s/::/$__expand_ipv6_expanded/")"
		;;
	esac

	__expand_ipv6_blocks="$(echo "$__expand_ipv6_ip" | grep -o '[0-9a-f]\+' | while read -r __expand_ipv6_hex; do [ -n "$__expand_ipv6_hex" ] && printf " %d" "$((0x$__expand_ipv6_hex))"; done)"
	printf "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x" $__expand_ipv6_blocks
	printf "%s\n" "$__expand_ipv6_mask"
}
compress_ipv6()
{
	__compress_ipv6_ip="$1"
	
	__compress_ipv6_mask=""
	case "$__compress_ipv6_ip" in
		*/*)
			__compress_ipv6_mask="/${__compress_ipv6_ip#*/}"
			__compress_ipv6_ip="${__compress_ipv6_ip%/*}"
		;;
	esac
	
	__compress_ipv6_ip="$(echo "$__compress_ipv6_ip" | sed -e 's/::/:0:/g' | grep -o "[0-9a-f]\+" | while read -r __compress_ipv6_hex; do [ -n "$__compress_ipv6_hex" ] && printf ":%x" "$((0x$__compress_ipv6_hex))"; done)"
	
	for __compress_ipv6_chain in :0:0:0:0:0:0:0:0 :0:0:0:0:0:0:0 :0:0:0:0:0:0 :0:0:0:0:0 :0:0:0:0 :0:0:0 :0:0 :0
	do
		case "$__compress_ipv6_ip" in
			*$__compress_ipv6_chain*)
				__compress_ipv6_ip="$(echo "$__compress_ipv6_ip" | sed -e "s/$__compress_ipv6_chain/::/" -e 's/:::/::/')"
				break
		esac
	done
	
	case "$__compress_ipv6_ip" in
		::*) ;;
		:*) __compress_ipv6_ip="${__compress_ipv6_ip#:}"
	esac
	
	echo "$__compress_ipv6_ip$__compress_ipv6_mask"
}
hex_to_expanded_ipv6()
{
	# the result might be 123456, but then it should turn into: 1234:5600
	# so always make sure, that the amount of input digits is rounded to 4, and append 0's
	
	__hex_to_expanded_ipv6_addr="$1"
	while [ "$((${#__hex_to_expanded_ipv6_addr} % 4))" -ne 0 ]
	do
		__hex_to_expanded_ipv6_addr="${__hex_to_expanded_ipv6_addr}0"
	done
	
	expand_ipv6 "$(sed -e 's/.\{4\}/&:/g;s/:$//' <<<"${__hex_to_expanded_ipv6_addr:0:32}")"
}
apply_ipv6_mask()
{
	# note: input may not contain a ($) cost metric
	__apply_ipv6_mask_input="$1"
	
	case "$__apply_ipv6_mask_input" in
		*/128) ;; # 128 is most specific, so no removal of digits required
		*/*)
			# extract mask
			__apply_ipv6_mask_mask="${__apply_ipv6_mask_input#*/}"
			# extract address
			__apply_ipv6_mask_addr="${__apply_ipv6_mask_input%/*}"
			# expand address
			read -r __apply_ipv6_mask_addr < <(expand_ipv6 "$__apply_ipv6_mask_addr")
			# remove colons
			__apply_ipv6_mask_addr="${__apply_ipv6_mask_addr//:/}"
			# remove trailing digits given the mask
			__apply_ipv6_mask_addr="${__apply_ipv6_mask_addr:0:$((__apply_ipv6_mask_mask / 4))}"
			# put colons back in
			read -r __apply_ipv6_mask_addr < <(hex_to_expanded_ipv6 "$__apply_ipv6_mask_addr")
			# reconstruct the address with mask
			__apply_ipv6_mask_input="$__apply_ipv6_mask_addr/$__apply_ipv6_mask_mask"
		;;
		*) ;; # no mask, is same as /128
	esac
	
	compress_ipv6 "$__apply_ipv6_mask_input"
}
is_ipv6()
{
	ip -6 route get "$1" >/dev/null 2>/dev/null || [ $? -ne 1 ]
}
is_ipv4()
{
	ip -4 route get "$1" >/dev/null 2>/dev/null || [ $? -ne 1 ]
}
is_hostname()
{
	! is_ipv4 && ! is_ipv6
}
is_mac_addr()
{
	case "$1" in
		[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]) return 0
	esac
	return 1
}
is_num()
{
	case "$1" in
		''|*[!0-9]*)
			# matched empty string, or contains non-numeric char
		;;
		*)
			return 0
		;;
	esac
	return 1
}
cmd()
{
	echo "> $*"
	"$@"
}
ensure_ip6tables()
{
	if ! ip6tables-save | grep -qFx -- "$*"
	then
		cmd ip6tables "$@"
	fi
}
ensure_ip()
{
	echo "> ip $*"
	__ensure_ip_code="0"
	__ensure_ip_err="$(ip "$@" 2>&1)" || __ensure_ip_code="$?"
	
	if [ "$__ensure_ip_code" == "0" ]
	then
		return 0
		
	elif [ "$__ensure_ip_code" == "2" ]
	then
	       	case "$__ensure_ip_err" in
			*File\ exists*)
				return 0
			;;
			*)
				echo "error: ($__ensure_ip_code) Failed to execute command ($*)."
				return 1
		esac
	else
		echo "error: ($__ensure_ip_code) Failed to execute command ($*)."
		return 1
	fi
}
ensure_ip6route()
{
	ensure_ip -6 route append "$@"
}
ensure_ip6address()
{
	ensure_ip -6 address add "$@"
}
strip_ipv6_brackets()
{
	__strip_ipv6_brackets_addr="${1%%]*}"
	__strip_ipv6_brackets_addr="${__strip_ipv6_brackets_addr##*[}"
	echo "$__strip_ipv6_brackets_addr"
}
ensure_ipv6_brackets()
{
	case "$1" in
		\[*:*:*) ;;
		*:*:*)
			echo "[$1]"
			return 0
	esac
	echo "$1"
}
strtolower()
{
	tr '[:upper:]' '[:lower:]' <<<"$1"
}
strtoupper()
{
	tr '[:lower:]' '[:upper:]' <<<"$1"
}
# usage note: join works with multiple characters
join()
{
	__join_delim="$1"
	shift
	if [ "$#" -gt 0 ]
	then
		echo -n "$1"
		shift
		for __join_elem in "$@"
		do
			echo -n "$__join_delim$__join_elem"
		done
	fi
	echo
}
# usage note: only works with a delimiter of 1 character, automatically trims every entry, and values should not contain ' or \
# usage: split ',' "$csv" array
# usage: array=($(split ',' "$csv"))
split()
{
	__split_delim="$1"
	__split_input="$2"
	__split_var="$3"
	
	while read -d "$__split_delim" -r __split_entry
	do
		# trim entry
		read -r __split_entry <<<"$__split_entry"
		
		# skip empty entries
		[ -n "$__split_entry" ] || continue
		
		if [ -n "$__split_var" ]
		then
			# assign entry to array (if given), first use printf %q to escape special characters
			read -r __split_entry < <(printf '%q' "$__split_entry")
			eval "$__split_var+=($__split_entry)"
		else
			# print every entry on a new line
			echo "$__split_entry"
		fi
		
	done <<<"$__split_input$__split_delim"
}
sock_send()
{
	printf "%s\n" ">> $*" >&2
	printf "%s\n" "$*"
}
sock_send_lines()
{
	for __sock_send_lines_ln in "$@"
	do
		sock_send "$__sock_send_lines_ln"
	done
}
sock_receive()
{
	printf "%s\n" "<< $*" >&2
}

# robustly detect whether to use IPv4 or IPv6 (for systems that exclusively have either IPv4 or IPv6 connections)
get_ip_family() # <hostname> [port], returns "tcp4" or "tcp6"
{
	read -r __get_ip_family_hostname < <(strip_ipv6_brackets "$1")
	__get_ip_family_family="tcp4"
	
	__get_ip_family_ipv4_count=0
	__get_ip_family_ipv6_count=0
	
	while read -r __get_ip_family_addr
	do
		case "$__get_ip_family_addr" in
			*[:]*)
				# is IPv6
				__get_ip_family_ipv6_count=$((__get_ip_family_ipv6_count + 1))
			;;
			*[0-9][.]*)
				# is IPv4
				__get_ip_family_ipv4_count=$((__get_ip_family_ipv4_count + 1))
			;;
		esac
		
	done < <({ getent hosts "$__get_ip_family_hostname" 2>/dev/null; getent ahosts "$__get_ip_family_hostname" 2>/dev/null; } | awk '{print $1}' | sort -u)
	
	# check which family has more addresses in the given hostname (hostname can also already be IPv4 or IPv6 directly, passthrough works here)
	if [ "$__get_ip_family_ipv4_count" -eq 0 ] && [ "$__get_ip_family_ipv6_count" -gt 0 ]
	then
		__get_ip_family_family="tcp6"
		
	elif [ "$__get_ip_family_ipv6_count" -eq 0 ] && [ "$__get_ip_family_ipv4_count" -gt 0 ]
	then
		__get_ip_family_family="tcp4"
	fi
	
	# check with ping which family is reachable
	case "$__get_ip_family_family" in
		tcp4)
			# we already assume tcp4, only change if tcp4 is not reachable, but tcp6 is
			if ! ping -4 -c 1 -w 4 "$__get_ip_family_hostname" >/dev/null && ping -6 -c 1 -w 3 "$__get_ip_family_hostname" >/dev/null
			then
				__get_ip_family_family="tcp6"
			fi
		;;
		tcp6)
			# we already assume tcp6, only change if tcp6 is not reachable, but tcp4 is
			if ! ping -6 -c 1 -w 4 "$__get_ip_family_hostname" >/dev/null && ping -4 -c 1 -w 3 "$__get_ip_family_hostname" >/dev/null
			then
				__get_ip_family_family="tcp4"
			fi
		;;
	esac
	
	# detect IP-address family based on whichever connection succeeds (only if a port was provided)
	if [ -n "$2" ]
	then
		# socat needs brackets around IPv6 address (only if hostname is an IPv6 address)
		read -r __get_ip_family_hostname_socat < <(ensure_ipv6_brackets "$__get_ip_family_hostname")
		
		case "$__get_ip_family_family" in
			tcp4)
				if ! socat /dev/null tcp4:"$__get_ip_family_hostname_socat":"$2",connect-timeout=4 >/dev/null && socat /dev/null tcp6:"$__get_ip_family_hostname_socat":"$2",connect-timeout=3 >/dev/null
				then
					__get_ip_family_family="tcp6"
				fi
			;;
			tcp6)
				if ! socat /dev/null tcp6:"$__get_ip_family_hostname_socat":"$2",connect-timeout=4 >/dev/null && socat /dev/null tcp4:"$__get_ip_family_hostname_socat":"$2",connect-timeout=3 >/dev/null
				then
					__get_ip_family_family="tcp"
				fi
			;;
		esac
	fi
	
	echo "$__get_ip_family_family"
}
is_http()
{
	__is_http_host="$1"
	__is_http_port="$2"
	
	# ports 80 and 443 are reserved for HTTP/HTTPS
	case "$__is_http_port" in
		80|443)
			return 0
		;;
	esac
	
	# check which IP-address family to use for socat
	read -r __is_http_ip_family < <(get_ip_family "$__is_http_host" "$__is_http_port")
	
	# do a HEAD request to check if we're dealing with a webserver
	read __is_http_res _ < <(sed -r -e 's/([^\r]|^)$/\1\r/' <<EOF | socat -t"$PROTOCOL_TIMEOUT_S" - "${__is_http_ip_family:-tcp}":"$__is_http_host":"$__is_http_port"
HEAD / HTTP/1.1
Host: $__is_http_host
User-Agent: wg-autoconf/1.0
Accept: */*

EOF
	)
	
	case "$__is_http_res" in
		HTTP/*)
			return 0
		;;
	esac
	
	return 1
}
array_contains()
{
	__array_contains_needle="$1"
	shift
	for __array_contains_arg in "$@"
	do
		if [ "$__array_contains_arg" = "$__array_contains_needle" ]
		then
			return 0
		fi
	done
	return 1
}
emit_server_event()
{
	__emit_server_event_interface="$1"
	__emit_server_event_event="$2"
	shift 2
	for f in "/etc/wg-server@$__emit_server_event_interface.d/$__emit_server_event_event/"*
	do
		if [ -f "$f" ] && [ -x "$f" ]
		then
			# execute script
			echo "info: Emit server event: $f $*"
			WG_AUTOCONF="$0" WG_AUTOCONF_INTERFACE="$__emit_server_event_interface" WG_AUTOCONF_EVENT="$__emit_server_event_event" "$f" "$@"
		fi
	done
}


print_usage()
{
	context="$1"
	case "$context" in
		server|client|conf|wg) ;;
		*) context=""
	esac
	
	echo "wg-autoconf: Automated Wireguard configuration cli-tool."
	echo ""
	echo "DEPENDENCIES"
	echo " -> wg"
	echo " -> socat"
	echo " -> ip6tables"
	echo " -> flock, ip, grep, sed, cat (busybox)"
	echo " -> any modern Linux shell (bash)"
	echo ""
	echo ""
	echo "USAGE"
	echo "  $0 [OPTIONS] <interface> ${context:-[CONTEXT]} <COMMAND>"
	echo ""
	echo "OPTIONS"
	echo "  -v                   Increase verbosity."
	echo "  -h, --help <context> Show this help. Context can be any of server, client,"
	echo "                       or conf."
	echo "                       Defaults to: Show help for all contexts."
	echo ""
	echo "COMMANDS"
	echo ""
	echo "  find"
	echo ""
	echo "      Find a client by its Interface ID (the trailing end of the virtual"
	echo "      IPv6-address."
	echo ""
	echo "  update"
	echo ""
	echo "      Synchronize configuration file with the Wireguard interface, and ensure"
	echo "      all ip6tables rules and ip routes are setup correctly. Does not bring"
	echo "      the Wireguard interface up if it is down."
	echo ""
	echo "  up"
	echo ""
	echo "      Same as update, but also ensures the Wireguard interface is brought up."
	echo ""
	echo "  down"
	echo ""
	echo "      Bring the Wireguard interface down. All ip6tables and ip routes rules"
	echo "      are also cleaned up."
	echo ""
	echo ""
	if [ -z "$context" ] || [ "$context" = "conf" ]
	then
		echo "CONF COMMANDS"
		echo ""
		echo "  conf show"
		echo ""
		echo "      Print the contents of the configuration file."
		echo ""
		echo "  conf get-interface [entry]"
		echo ""
		echo "      Print the Interface-section of the configuration file."
		echo "      If an entry is specified, only the value of that entry is printed."
		echo "      If an entry has multiple values separated by a comma, these values"
		echo "      are printed on separate lines."
		echo ""
		echo "  conf get-peer <public-key> [entry]"
		echo ""
		echo "      Print the Peer-section of the configuration file, that contains a"
		echo "      PublicKey entry with the given public-key value."
		echo "      If an entry is specified, only the value of that entry is printed."
		echo "      If an entry has multiple values separated by a comma, these values"
		echo "      are printed on separate lines."
		echo ""
		echo "  conf strip"
		echo ""
		echo "  conf list-peers"
		echo ""
		echo "  conf set-peer"
		echo ""
		echo ""
	fi
	if [ -z "$context" ] || [ "$context" = "server" ]
	then
		echo "SERVER COMMANDS"
		echo ""
		echo "  server connect <host> [port]"
		echo ""
		echo "      Connect to the given server running wg-autoconf listen."
		echo "      To be run by a server. Will register itself (as a server) at the remote"
		echo "      server. If the local public key is authorized by the remote server, the"
		echo "      remote server will append a Peer-section with this local server as its"
		echo "      endpoint."
		echo "      Port defaults to $WIREGUARD_PORT."
		echo ""
		echo "  server listen [port]"
		echo ""
		echo "      Listen at the given TCP-port."
		echo "      Any remote clients and servers can connect, and if authorized, be added"
		echo "      to the subnet that this server provides."
		echo "      Port defaults to $WIREGUARD_PORT."
		echo ""
		echo "  server allow <public-key> [Type=<server|client>]"
		echo ""
		echo "      Allow Peer identified by the given Public Key to connect."
		echo "      Ensures a Peer-section in the configuration file."
		echo "      If Type is set to server, the Peer will be able to register its own"
		echo "      Endpoint and AllowedIPs entries upon connect."
		echo ""
		echo "  server deny <public-key>"
		echo ""
		echo "      Deny Peer identified by the given Public Key from connecting."
		echo "      Removes a Peer-section from the configuration file."
		echo ""
		echo ""
		echo "SERVER CONNECT OPTIONS"
		echo ""
		echo "  -k <seconds>      Set persistent keepalive seconds."
		echo "                    Defaults to: $DEFAULT_PERSISTENT_KEEPALIVE_S"
		echo ""
		echo ""
		echo "SERVER LISTEN OPTIONS"
		echo ""
		echo "  -a <ipv6-address> Set address of the server in the virtual IPv6 network"
		echo "                    Also use a mask to specify the subnet mask of this server."
		echo "                    Defaults to: $DEFAULT_VPN_ADDRESS"
		echo "  -b <bind-host>    Set host to bind to."
		echo "                    Defaults to: $DEFAULT_BIND_HOST"
		echo "                    Use 0.0.0.0 to bind to every IPv4 interface."
		echo "                    Use :: to bind to every IPv6 interface."
		echo "                    In order to listen at both IPv4 and IPv6 interfaces, two"
		echo "                    separate instances must be run."
		echo "  -p <mask>         Specify a bitmask for the prefix division. The client will"
		echo "                    use this to setup routing. This ensures that if a new"
		echo "                    server is added to the mesh, the client can immediately"
		echo "                    route traffic to the new server as well."
		echo "                    Defaults to: $DEFAULT_VPN_PREFIX_MASK"
		echo ""
		echo ""
	fi
	if [ -z "$context" ] || [ "$context" = "client" ]
	then
		echo "CLIENT COMMANDS"
		echo ""
		echo "  client connect <host> [port]"
		echo ""
		echo "      Connect to the given server running wg-autoconf listen."
		echo "      To be run by a client, any existing configuration for this interface"
		echo "      will be completely overwritten. Do NOT run as server, since all"
		echo "      existing clients will be disconnected, and manual configuration changes"
		echo "      will be deleted."
		echo "      Protocol will first try to use HTTP using libcurl, following potential"
		echo "      redirects like switching to HTTPS."
		echo "      Port defaults to 80 if HTTP detected, and otherwise: $WIREGUARD_PORT"
		echo ""
		echo ""
		echo "CLIENT CONNECT OPTIONS"
		echo ""
		echo "  -m [MAC-address]  Set the Interface ID part of the IPv6 address. If the"
		echo "                    MAC-address is not defined, then it will default to the"
		echo "                    first available network device, which is then cached for"
		echo "                    subsequent connects in: /etc/wireguard/<interface>.id"
		echo "                    The server is not guaranteed to incorporate the"
		echo "                    Interface ID into the client's allowed IP address (i.e."
		echo "                    in case the ID is not unique)."
		echo "  -k <seconds>      Set persistent keepalive seconds."
		echo "                    Defaults to: $DEFAULT_PERSISTENT_KEEPALIVE_S"
		echo ""
		echo ""
	fi
	if [ -z "$context" ]
	then
		echo "AUTOCONF CONFIGURATION FILE"
		echo ""
		echo "wg-autoconf uses extended properties in the configuration file. In order to"
		echo "generate a configuration that Wireguard can work with, use:"
		echo ""
		echo "    wg syncconf <interface> <(wg-autoconf conf strip <interface>)"
		echo ""
		echo ""
		echo "AUTOCONF PROTOCOL"
		echo ""
		echo "wg-autoconf listens on the same port as WireGuard. Since wg-autoconf uses"
		echo "TCP, and WireGuard uses UDP, there is no conflict."
		echo ""
		echo "Within the virtual network, only IPv6-addresses are supported due to its"
		echo "additional flexibility. For the real non-virtual network, both IPv4 and IPv6"
		echo "are supported."
		echo ""
		echo ""
		echo "IPV6 FORWARDING AND IP6TABLES"
		echo ""
		echo "Note that when using listen, IPv6 forwarding is enabled (and accept_ra is set"
		echo "to 2). This is why, for security, the default policy of the FORWARD chain will"
		echo "be set to DROP. That is, no IPv6 forwarding is allowed unless explicitly"
		echo "accepted by a rule in the FORWARD chain of ip6tables."
		echo ""
		echo "Any ip6tables rules that are added by wg-autoconf, will be in a separate chain"
		echo "and will be automatically cleaned up when running the down command."
		echo ""
		echo ""
		echo "RECOMMENDED IPV6 ALLOCATION"
		echo ""
		echo "  <prefix> : <server> : <subnet> : <unused> : <interface-identifier>"
		echo ""
		echo "Where:"
		echo " -> prefix is a unique identifier for this virtual private network."
		echo " -> server is a unique identifier for each individual server (i.e. site)."
		echo " -> subnet isolates clients from each other that are in different subnets."
		echo " -> unused is a further custom distinction of client groups, may be left zero."
		echo " -> interface-identifier is a 64-bit identifier reserved to uniquely identify"
		echo "    clients across multiple subnets and groups. By default this is the"
		echo "    MAC-address of the client."
		echo ""
		echo ""
		echo "TROUBLESHOOTING"
		echo ""
		echo " 1. Check if interface is up and has the intended virtual IPv6-address"
		echo " 2. Check if IPv6-forwarding is enabled, using:"
		echo ""
		echo "      cat /proc/sys/net/ipv6/conf/<wg0|all>/forwarding"
		echo ""
		echo " 3. Check if the virtual IPv6-address is routed correctly, using:"
		echo ""
		echo "      ip -6 route show [dev wg0]"
		echo ""
		echo " 4. Check if the route is blocked by netfilter with ip6tables:"
		echo ""
		echo "      ip6tables -L"
		echo ""
		echo " 5. Check from the client's perspective if the Endpoint IP-address in"
		echo "    the [Peer] section that belongs to the server is correct."
		echo " 6. Check if the port in the Endpoint from step 5 is correct."
		echo " 7. Check if the port from step 6 matches the ListenPort on the server:"
		echo "    wg show <wg0> listen-port"
		echo " 8. Check if the PublicKey entry of the [Peer] section matches the"
		echo "    PublicKey generated from the PrivateKey of the [Interface] section"
		echo "    of the other peer. Check both ends. If one end is misconfigured,"
		echo "    then the whole connection fails."
		echo ""
		echo "Wireguard uses the UDP-protocol, the wg-autoconf utility uses TCP-protocol."
		echo "Debug UDP traffic using:"
		echo ""
		echo "    tcpdump -n udp"
		echo ""
		echo "If ping to a virtual address fails with:"
		echo ""
		echo "    Destination unreachable: Address unreachable"
		echo ""
		echo "then the traffic is correctly locally routed through the Wireguard link"
		echo "device, but Wireguard responds that the virtual target IPv6-address is"
		echo "unreachable. Check the AllowedIPs of the relevant [Peer] section."
		echo ""
		echo "Wireguard will give a warning:"
		echo ""
		echo "    warning: AllowedIP has nonzero host part"
		echo ""
		echo "which can be safely ignored. It indicates a subnet mask catches more than"
		echo "one specific IPv6-address, and thus for clarity it should end with zeroes"
		echo "(::). But wg-autoconf specifies the address anyway, to store the IP-address"
		echo "of the server itself."
		echo ""
		echo "If a server is added to the mesh, all previously connected peers (clients"
		echo "and servers) must reconnect using wg-autoconf. So that the new IP-addresses"
		echo "are propagated. If the mesh is dynamic, it is highly recommended to use"
		echo "wg-monitor which automatically propagates updates through the mesh network"
		echo "and furthermore keeps connections alive (to achieve redundancy)."
		echo ""
		echo ""
		
	fi
}


context_wg()
{
	opts_command="$1"
	shift
	
	[ -z "$1" ] || opts_interface="$1"
	read -r chain < <(strtoupper "${opts_interface//-/_}")
	
	# TODO: check if opts_interface name is too long, this is also limited by the max. length of ip6tables rules +'_FW_ALLOW' = +9 chars, error if too long
	
	case "$opts_command" in
		down)
			# delete link device (which automatically removes all routes relating to this device)
			cmd ip link delete dev "$opts_interface"
			
			# cleanup ip6tables rules after device is removed and down
			cmd ip6tables -D INPUT -j "$chain"_IN
			cmd ip6tables -F "$chain"_IN
			cmd ip6tables -X "$chain"_IN
			
			cmd ip6tables -D FORWARD -i "$opts_interface" -j "$chain"_FW
			cmd ip6tables -F "$chain"_FW
			cmd ip6tables -X "$chain"_FW
			
			cmd ip6tables -D "$chain"_FW -j "$chain"_FW_ALLOW
			cmd ip6tables -F "$chain"_FW_ALLOW
			cmd ip6tables -X "$chain"_FW_ALLOW
		;;
		up|update)
			# exit on any failure
			set -e
			
			if ! [ -e "/etc/wireguard/$opts_interface.conf" ]
			then
				echo "error: Configuration file does not exist (/etc/wireguard/$opts_interface.conf)."
				echo "Initialize the Wireguard interface ($opts_interface) for the first time using either:"
				echo ""
				echo "  $0 $opts_interface server listen"
				echo ""
				echo "or:"
				echo ""
				echo "  $0 $opts_interface client connect <server>"
				echo ""
				echo "Alternatively, read the manual for correct usage with:"
				echo ""
				echo "  $0 --help"
				echo ""
				exit 1
			fi
			
			wg_confset="syncconf"
			
			if ! [ -e "/sys/class/net/$opts_interface" ]
			then
				# first time set configuration
				wg_confset="setconf"
				
				# ensure default policy of ip6tables is to DROP, unless caught by any filter chain
				cmd ip6tables -P FORWARD DROP
				
				# create link device
				cmd ip link add "$opts_interface" type wireguard
			fi
			
			# apply ip6tables rules before the device is up, but after device is created
			if cmd ip6tables -N "$chain"_IN
			then
				# cmd ip6tables -A "$chain"_IN -p udp -i "$opts_interface" -j ACCEPT
				cmd ip6tables -I INPUT -j "$chain"_IN
			fi
			
			if cmd ip6tables -N "$chain"_FW
			then
				cmd ip6tables -A "$chain"_FW -m state --state INVALID -j DROP
				cmd ip6tables -A "$chain"_FW -m state --state RELATED,ESTABLISHED -j ACCEPT
				cmd ip6tables -A "$chain"_FW -j DROP
				cmd ip6tables -I FORWARD -i "$opts_interface" -j "$chain"_FW
			fi
			
			if cmd ip6tables -N "$chain"_FW_ALLOW
			then
				# there are 3 rules in "$chain"_FW, add before the DROP
				cmd ip6tables -I "$chain"_FW 3 -j "$chain"_FW_ALLOW
			fi
			
			iptables_chain_in=0
			iptables_chain_fw_allow=0
			
			# only set interface up if "up" command, with "update", don't actually bring the interface up
			if [ "$opts_command" = "up" ]
			then
				# state UP, and configure MTU
				cmd ip link set mtu "$DEFAULT_MTU" up dev "$opts_interface"
			fi
			
			# accept all input/output traffic for the Wireguard device (for any port)
			cmd ip6tables -I "$chain"_IN 1 -i "$opts_interface" -j ACCEPT
			((++iptables_chain_in))
			
			insert_ip6tables_listenport()
			{
				cmd ip6tables -I "$chain"_IN 1 -p udp --dport "$listen_port" -j ACCEPT
				((++iptables_chain_in))
				
				cmd ip6tables -I "$chain"_IN 1 -p tcp --dport "$listen_port" -j ACCEPT
				((++iptables_chain_in))
			}
			
			# detect automatically allocated ListenPort
			read -r listen_port < <("$0" "$opts_interface" conf get-interface ListenPort) || true
			
			# add rules to allow ListenPort BEFORE applying the configuration (for seamless transition to another ListenPort)
			[ -z "$listen_port" ] || insert_ip6tables_listenport
			
			# synchronize configuration with wireguard (use wg-quick if available, for custom rules fallback)
			# a dynamic ListenPort is assigned if no ListenPort is explicitly set
			cmd "$0" "$opts_interface" "$wg_confset" "$opts_interface" <("$0" "$opts_interface" conf strip)
			
			# if no ListenPort is explicitly set, grab the dynamically assigned one, and update ip6tables rules
			if [ -z "$listen_port" ]
			then
				read -r listen_port < <("$0" "$opts_interface" show "$opts_interface" listen-port) || true
				[ -n "$listen_port" ] || listen_port="$WIREGUARD_PORT"
				
				insert_ip6tables_listenport
			fi
			
			# grab the configured PrefixMask (servers in the same mesh should have this statically configured, and clients will receive this value from the server, or assume the default)
			read -r local_PrefixMask < <("$0" "$opts_interface" conf get-interface PrefixMask) || true
			[ -n "$local_PrefixMask" ] || local_PrefixMask="$DEFAULT_VPN_PREFIX_MASK"
			
			has_address=false
			is_server=true
			
			# instead of: cmd ip -6 address flush dev "$opts_interface", we can seamlessly remove old addresses, by keeping track of added addresses:
			added_ip6_addresses=()
			
			# add link device addresses
			while read -r address
			do
				[ -n "$address" ] || continue
				
				# NOTE: cost is provided by a server to the client to indicate which AllowedIPs it is connected to, so that a client may know the size of the mesh that the server is in, and which servers are curerntly available
				
				# Interface-address is currently not supposed to have a metric cost, but it might be in future, so simply trim the cost if it exists
				address="${address%\$*}"
				
				# normalize address
				case "$address" in
					*/*) ;;
					*) address="$address/128"
				esac
				
				case "$address" in
					*/128)
						is_server=false
					;;
				esac
				
				# subnet mask is not allowed in a link address, so force /128
				ensure_ip6address "${address%/*}/128" dev "$opts_interface"
				added_ip6_addresses+=("${address%/*}/128")
				has_address=true
				
				# expand address
				read -r expanded_addr < <(expand_ipv6 "$address" | tr -d ':')
				
				# back to a correct ipv6 address
				read -r addr < <(hex_to_expanded_ipv6 "${expanded_addr:0:$(($local_PrefixMask/4))}")
				
				# ensure routing for the given prefix (normally the first 32 bits)
				ensure_ip6route "$addr/$local_PrefixMask" dev "$opts_interface" metric "$DEFAULT_METRIC"
				
				# enable forwarding of traffic to any local device address
				cmd ip6tables -I "$chain"_FW_ALLOW 1 -d "${address%/*}/128" -o "$opts_interface" -j ACCEPT
				((++iptables_chain_fw_allow))
				
				# enable forwarding of traffic from any local device address
				cmd ip6tables -I "$chain"_FW_ALLOW 1 -s "${address%/*}/128" -o "$opts_interface" -j ACCEPT
				((++iptables_chain_fw_allow))
				
			done < <("$0" "$opts_interface" conf get-interface Address)
			
			if ! $has_address
			then
				echo "warning: Device $opts_interface has no virtual IPv6-address assigned. Check [Interface] Address configuration." >&2
			fi
			
			# check existing addresses
			while read -r _ _ _ address _
			do
				found=false
				for added_ip6_address in "${added_ip6_addresses[@]}"
				do
					if [ "$added_ip6_address" = "$address" ]
					then
						found=true
					fi
				done
				
				if ! $found
				then
					# this is an old address, maybe the address changed, so remove it
					cmd ip -6 address del "$address" dev "$opts_interface" scope global
				fi
				
			done < <(ip -iec -oneline -6 address show dev "$opts_interface" scope global)
			
			# one IP per line, multiple lines may belong to one peer
			while read -r pubkey address
			do
				[ -n "$address" ] || continue
				
				# AllowedIPs may contain cost ($), if non-zero, then this indicates that the given server can forward traffic for the given IP/mask
				address="${address%\$*}"
				
				# expand address
				read -r expanded_addr < <(expand_ipv6 "$address" | tr -d ':')
				
				# back to a correct ipv6 address
				read -r addr < <(hex_to_expanded_ipv6 "${expanded_addr:0:$(($local_PrefixMask/4))}")
				
				# ensure routing for the given prefix (normally the first 32 bits)
				ensure_ip6route "$addr/$local_PrefixMask" dev "$opts_interface" metric "$DEFAULT_METRIC"
				
				# enable forwarding of all traffic of this server's AllowedIPs, the server must check if it will locally allow that traffic
				# read -r normalized_addr < <(apply_ipv6_mask "${address%\$*}")
				# cmd ip6tables -I "$chain"_FW_ALLOW 1 -d "$normalized_addr" -o "$opts_interface" -j ACCEPT
				# ((++iptables_chain_fw_allow))
				
				# enable forwarding of traffic to any known server
				cmd ip6tables -I "$chain"_FW_ALLOW 1 -d "${address%/*}/128" -o "$opts_interface" -j ACCEPT
				((++iptables_chain_fw_allow))
				
				# enable forwarding of traffic from any known server
				cmd ip6tables -I "$chain"_FW_ALLOW 1 -s "${address%/*}/128" -o "$opts_interface" -j ACCEPT
				((++iptables_chain_fw_allow))
				
			done < <("$0" "$opts_interface" conf list-servers AllowedIPs)
			
			# FLAG: this allows any client to communicate with any other client in the same network:
			# allow forwarding of all traffic within the same interface
			#cmd ip6tables -I "$chain"_FW_ALLOW 1 -o "$opts_interface" -j ACCEPT
			#((++iptables_chain_fw_allow))
			
			# FLAG: to enable masquerading, we would need to allow traffic going to the MasqueradeInterface and back into the Wireguard interface
			
			# allow IPv6 forwarding
			cmd sysctl net.ipv6.conf.all.accept_ra=2
			cmd sysctl net.ipv6.conf.all.forwarding=1
			
			# delete old rules
			while cmd ip6tables -D "$chain"_IN "$((iptables_chain_in + 1))"
			do
				echo "info: Removed old rule from ${chain}_IN"
			done
			while cmd ip6tables -D "$chain"_FW_ALLOW "$((iptables_chain_fw_allow + 1))"
			do
				echo "info: Removed old rule from ${chain}_FW_ALLOW"
			done
			
			"$0" "$opts_interface" show "$opts_interface"
			
			echo "info: Success"
		;;
	esac
}


context_conf()
{
	opts_command="$1"
	shift
	
	conf_file="/etc/wireguard/$opts_interface.conf"
	
	case "$opts_command" in
		has-address)
			
			# usage note: address must be a single and compressed IPv6 address
			
			# remove comments from conf_file, and then check if the address exists in ANY section in ANY key
			# TODO: make this more strict, only check Address and AllowedIPs entries in Interface and Peer sections respectively
			
			if grep -qE '(,|\s|=)'"$1"'([/$],|\s|$)' <(sed -r -e 's/#.*$//g' <"$conf_file")
			then
				exit 0
			else
				exit 1
			fi
		;;
		strip)
			
			# print Interface-section
			"$0" "$opts_interface" conf get-interface | sed -r -n -e '/^\s*(\[Interface\]|(PrivateKey|ListenPort|FwMark)\s*=)/p'
			
			# print all Peer-sections (and strip $cost metric from every IP in AllowedIPs)
			"$0" "$opts_interface" conf list-peers | sed -r -n -e '/^\s*AllowedIPs\s*=/ s/[$][0-9]+//g' -e '/^\s*(\[Peer\]|(PublicKey|PresharedKey|AllowedIPs|Endpoint|PersistentKeepalive)\s*=)/p'
			
			# TODO: the "AllowedIP has nonzero host part" warning can be prevented by filtering the config accordingly (in: wg-autoconf conf strip)
			# this can only be done by parsing every AllowedIP, expanding the IPv6 address, setting every digit beyond the subnet mask to zero, and then compressing again, before printing it
			
			exit 0
		;;
	esac
	
	# advanced config rewriting or printing:
	
	set -e # exit on any failure
	
	reset_section_values()
	{
		interface_PrivateKey=""
		interface_Address=()
		interface_ListenPort=""
		interface_Endpoint=""
		interface_InterfaceID=""
		interface_PrefixMask=""
		
		peer_PublicKey=""
		peer_Endpoint=""
		peer_AllowedIPs=()
		peer_PersistentKeepalive=""
		peer_Type=""
		peer_VirtualEndpoint=""
		peer_VirtualHostname=""
		
		section_buffer=()
		section=""
	}
	print_section_buffer()
	{
		if [ "$section" = "Interface" ]
		then
			printf '%s\n' "[Interface]"
			
			[ -z "$interface_PrivateKey" ] || printf '%s\n' "PrivateKey = $interface_PrivateKey"
			if [ "${#interface_Address[@]}" -gt 0 ]
			then
				for address in "${interface_Address[@]}"
				do
					printf '%s\n' "Address = $address"
				done
			fi
			[ -z "$interface_ListenPort" ] || printf '%s\n' "ListenPort = $interface_ListenPort"
			[ -z "$interface_Endpoint" ] || printf '%s\n' "Endpoint = $interface_Endpoint"
			[ -z "$interface_InterfaceID" ] || printf '%s\n' "InterfaceID = $interface_InterfaceID"
			[ -z "$interface_PrefixMask" ] || printf '%s\n' "PrefixMask = $interface_PrefixMask"
			
		elif [ "$section" = "Peer" ]
		then
			if [ -z "$peer_PublicKey" ]
			then
				# if no public key, delete whole Peer-section, because the main identifier of this Peer would be gone
				return 1
			fi
			
			printf '%s\n' "[Peer]"
			[ -z "$peer_Type" ] || printf '%s\n' "Type = $peer_Type"
			[ -z "$peer_PublicKey" ] || printf '%s\n' "PublicKey = $peer_PublicKey"
			[ -z "$peer_Endpoint" ] || printf '%s\n' "Endpoint = $peer_Endpoint"
			[ -z "$peer_VirtualEndpoint" ] || printf '%s\n' "VirtualEndpoint = $peer_VirtualEndpoint"
			if [ "${#peer_AllowedIPs[@]}" -gt 0 ]
			then
				for allowed_ip in "${peer_AllowedIPs[@]}"
				do
					printf '%s\n' "AllowedIPs = $allowed_ip"
				done
			fi
			[ -z "$peer_PersistentKeepalive" ] || printf '%s\n' "PersistentKeepalive = $peer_PersistentKeepalive"
		fi
		
		if [ "${#section_buffer[@]}" -gt 0 ]
		then
			for section_line in "${section_buffer[@]}"
			do
				printf '%s\n' "$section_line"
			done
		fi
		
		echo
	}
	peer_is_server()
	{
		if [ "$peer_Type" = "server" ] || [ -n "$peer_Endpoint" ]
		then
			return 0
		fi
		if [ "${#peer_AllowedIPs[@]}" -gt 0 ]
		then
			for allowed_ip in "${peer_AllowedIPs[@]}"
			do
				# if at least one virtual address exists that has a bitmask that is not 128
				# then it is also considered a server (even when no Endpoint has been assigned yet)
				# since maybe this server is only authorized, but has yet to connect
				case "$allowed_ip" in
					*/128) ;;
					*/*) return 0
				esac
			done
		fi
		return 1
	}
	process_section()
	{
		print_section_buffer
	}
	process_eof()
	{
		echo -n # nothing to add
	}
	
	case "$opts_command" in
		list-peers|list-servers|list-clients)
			process_section()
			{
				if [ "$section" != "Peer" ] || [ -z "$peer_PublicKey" ]
				then
					return 0
				fi
				
				if [ "$opts_command" = "list-servers" ] || [ "$opts_command" = "list-clients" ]
				then
					# a server is defined by either having an Endpoint, or having an AllowedIPs bitmask < 128
					if peer_is_server
					then
						if [ "$opts_command" != "list-servers" ]
						then
							return 0
						fi
						
					else # is client
						
						if [ "$opts_command" != "list-clients" ]
						then
							return 0
						fi
					fi
				fi
				
				if [ "$1" = "PublicKey" ]
				then
					[ -z "$peer_PublicKey" ] || printf '%s\n' "$peer_PublicKey"
					
				elif [ "$1" = "AllowedIPs" ]
				then
					for allowed_ip in "${peer_AllowedIPs[@]}"
					do
						[ -z "$allowed_ip" ] || printf '%s\t%s\n' "$peer_PublicKey" "$allowed_ip"
					done
				
				elif [ "$1" = "Endpoint" ]
				then
					[ -z "$peer_Endpoint" ] || printf '%s\t%s\n' "$peer_PublicKey" "$peer_Endpoint"
				
				elif [ "$1" = "VirtualEndpoint" ]
				then
					[ -z "$peer_VirtualEndpoint" ] || printf '%s\t%s\n' "$peer_PublicKey" "$peer_VirtualEndpoint"

				elif [ "$1" = "VirtualHostname" ]
				then
					[ -z "$peer_VirtualHostname" ] || printf '%s\t%s\n' "$peer_PublicKey" "$peer_VirtualHostname"

				elif [ "$1" = "Type" ]
				then
					[ -z "$peer_Type" ] || printf '%s\t%s\n' "$peer_PublicKey" "$peer_Type"
				
				elif [ "$1" = "PersistentKeepalive" ]
				then
					[ -z "$peer_PersistentKeepalive" ] || printf '%s\t%s\n' "$peer_PublicKey" "$peer_PersistentKeepalive"
				
				elif [ -n "$1" ]
				then
					return 1
					
				else
					print_section_buffer
				fi
			}
		;;
		get-interface)
			section_matched=false
			
			process_section()
			{
				if [ "$section" = "Interface" ]
				then
					section_matched=true
					
					case "$1" in
						Address)
							for address in "${interface_Address[@]}"
							do
								printf '%s\n' "$address"
							done
						;;
						PrivateKey)
							[ -z "$interface_PrivateKey" ] || printf '%s\n' "$interface_PrivateKey"
						;;
						ListenPort)
							[ -z "$interface_ListenPort" ] || printf '%s\n' "$interface_ListenPort"
						;;
						Endpoint)
							[ -z "$interface_Endpoint" ] || printf '%s\n' "$interface_Endpoint"
						;;
						InterfaceID)
							[ -z "$interface_InterfaceID" ] || printf '%s\n' "$interface_InterfaceID"
						;;
						PrefixMask)
							[ -z "$interface_PrefixMask" ] || printf '%s\n' "$interface_PrefixMask"
						;;
						'')
							print_section_buffer
						;;
						*)
							return 1
						;;
					esac
				fi
			}
			process_eof()
			{
				if ! $section_matched && [ -z "$1" ]
				then
					# print empty Interface, by default, if non-existing Interface section
					printf '%s\n' "[Interface]"
				fi
			}
		;;
		get-peer|get-server|get-client)
			section_matched=false
			
			print_partial_peer()
			{
				case "$1" in
					PublicKey)
						[ -z "$peer_PublicKey" ] || printf '%s\n' "$peer_PublicKey"
					;;
					AllowedIPs)
						for allowed_ip in "${peer_AllowedIPs[@]}"
						do
							printf '%s\n' "$allowed_ip"
						done
					;;
					PersistentKeepalive)
						[ -z "$peer_PersistentKeepalive" ] || printf '%s\n' "$peer_PersistentKeepalive"
					;;
					Endpoint)
						[ -z "$peer_Endpoint" ] || printf '%s\n' "$peer_Endpoint"
					;;
					VirtualEndpoint)
						[ -z "$peer_VirtualEndpoint" ] || printf '%s\n' "$peer_VirtualEndpoint"
					;;
					VirtualHostname)
						[ -z "$peer_VirtualHostname" ] || printf '%s\n' "$peer_VirtualHostname"
					;;
					Type)
						[ -z "$peer_Type" ] || printf '%s\n' "$peer_Type"
					;;
					'')
						print_section_buffer
					;;
					*)
						# Invalid section-key
						return 1
					;;
				esac
			}
			process_section()
			{
				if [ "$section" = "Peer" ] && [ "$peer_PublicKey" = "$1" ]
				then
					case "$opts_command" in
						get-peer)
							section_matched=true
							print_partial_peer "$2"
						;;
						get-server)
							if peer_is_server
							then
								section_matched=true
								print_partial_peer "$2"
							fi
						;;
						get-client)
							if ! peer_is_server
							then
								section_matched=true
								print_partial_peer "$2"
							fi
						;;
					esac
				fi
			}
			process_eof()
			{
				if ! $section_matched
				then
					# return non-zero exit code to indicate no Peer was matched
					exit 1
				fi
			}
		;;
		set-peer|set-interface)
			section_matched=false
			
			target_section=""
			case "$opts_command" in
				set-peer)
					if [ "$#" -eq 0 ]
					then
						echo "error: Invalid usage."
						echo "Usage: $0 conf set-peer <public-key>"
						exit 1
					fi
					
					target_section="Peer"
					target_PublicKey="$1"
				;;
				set-interface)
					target_section="Interface"
				;;
			esac
			
			process_section()
			{
				# if section not yet matched, and section matches target section, and PublicKey matches if peer
				if ! $section_matched && [ "$section" = "$target_section" ] && {
					[ "$target_section" != "Peer" ] || [ "$peer_PublicKey" = "$target_PublicKey" ]
				}
				then
					# read section from stdin, and overwrite values, if empty, it means to delete the value for that key
					# if a key is not explicitly defined, it will always be preserved
					
					# mark matched, otherwise the section is new, and will be appended at the end
					section_matched=true
					
					set_interface_Address=false
					new_interface_Address=()
					
					set_peer_Type=false
					set_peer_Endpoint=false
					set_peer_VirtualEndpoint=false
					set_peer_VirtualHostname=false
					set_peer_AllowedIPs=false
					set_peer_PersistentKeepalive=false
					new_peer_Type=""
					new_peer_Endpoint=""
					new_peer_VirtualEndpoint=""
					new_peer_VirtualHostname=""
					new_peer_AllowedIPs=()
					new_peer_PersistentKeepalive=""
					
					# you can use stdin or cli-args to set key&value pairs, but these methods cannot be mixed (enforce strict style consistency, to avoid bugs due to using undefined behavior if they are mixed and the implementation changes)
					if [ "$#" -gt 1 ]
					then
						# now read from args[1...] KeyHere=Value or key-here value styles are both supported
						key=""
						for arg in "${@:1}"
						do
							store_value=false
							
							case "$arg" in
								*=*)
									key="${arg%%=*}"
									value="${arg#*=}"
									store_value=true
								;;
								*)
									if [ -z "$key" ]
									then
										key="$arg"
									else
										value="$arg"
										store_value=true
									fi
								;;
							esac
							
							if $store_value
							then
								read -r key < <(strtolower "${key//-/}")
								
								case "$section" in
									Interface)
										case "$key" in
											privatekey)
												read -r interface_PrivateKey <<<"$value"
											;;
											address)
												set_interface_Address=true
												split ',' "$value" new_interface_Address
											;;
											listenport)
												read -r interface_ListenPort <<<"$value"
											;;
											endpoint)
												read -r interface_Endpoint <<<"$value"
											;;
											interfaceid)
												read -r interface_InterfaceID <<<"$value"
											;;
											prefixmask)
												read -r interface_PrefixMask <<<"$value"
											;;
										esac
									;;
									Peer)
										# note, PublicKey cannot be overwritten, since it's already used for matching
										# if it is possible to change the PublicKey, then uniqueness of PublicKey's is not guaranteed
										case "$key" in
											type)
												set_peer_Type=true
												read -r new_peer_Type < <(strtolower "$value")
											;;
											endpoint)
												set_peer_Endpoint=true
												read -r new_peer_Endpoint <<<"$value"
											;;
											virtualendpoint)
												set_peer_VirtualEndpoint=true
												read -r new_peer_VirtualEndpoint <<<"$value"
											;;
											virtualhostname)
												set_peer_VirtualHostname=true
												read -r new_peer_VirtualHostname <<<"$value"
											;;
											allowedips)
												set_peer_AllowedIPs=true
												split ',' "$value" new_peer_AllowedIPs
											;;
											persistentkeepalive)
												set_peer_PersistentKeepalive=true
												read -r new_peer_PersistentKeepalive <<<"$value"
											;;
										esac
									;;
								esac
							fi
						done
					else
						# assume default section is correct
						stdin_section="$section"
						while read -r stdin_line
						do
							# parse section name
							case "$stdin_line" in
								\[*)
									stdin_section="${stdin_line%%]*}"
									stdin_section="${stdin_section##*[}"
									continue
								;;
							esac
							
							# only handle of the current section, so if a section is defined, it must match the section were trying to set
							[ "$stdin_section" = "$section" ] || continue
							
							case "$stdin_section" in
								Interface)
									case "${stdin_line// /}" in
										PrivateKey=*)
											read -r interface_PrivateKey <<<"${stdin_line#*=}"
										;;
										Address=*)
											set_interface_Address=true
											split ',' "${stdin_line#*=}" new_interface_Address
										;;
										ListenPort=*)
											read -r interface_ListenPort <<<"${stdin_line#*=}"
										;;
										Endpoint=*)
											read -r interface_Endpoint <<<"${stdin_line#*=}"
										;;
										InterfaceID=*)
											read -r interface_InterfaceID <<<"${stdin_line#*=}"
										;;
										PrefixMask=*)
											read -r interface_PrefixMask <<<"${stdin_line#*=}"
										;;
									esac
								;;
								Peer)
									# note, PublicKey cannot be overwritten, since it's already used for matching
									# if it is possible to change the PublicKey, then uniqueness of PublicKey's is not guaranteed
									case "${stdin_line// /}" in
										Type=*)
											set_peer_Type=true
											read -r new_peer_Type < <(strtolower "${stdin_line#*=}")
										;;
										Endpoint=*)
											set_peer_Endpoint=true
											read -r new_peer_Endpoint <<<"${stdin_line#*=}"
										;;
										VirtualEndpoint=*)
											set_peer_VirtualEndpoint=true
											read -r new_peer_VirtualEndpoint <<<"${stdin_line#*=}"
										;;
										VirtualHostname=*)
											set_peer_VirtualHostname=true
											read -r new_peer_VirtualHostname <<<"${stdin_line#*=}"
										;;
										AllowedIPs=*)
											set_peer_AllowedIPs=true
											split ',' "${stdin_line#*=}" new_peer_AllowedIPs
										;;
										PersistentKeepalive=*)
											set_peer_PersistentKeepalive=true
											read -r new_peer_PersistentKeepalive <<<"${stdin_line#*=}"
										;;
									esac
								;;
							esac
						done # READ FROM STDIN
					fi
					
					# apply new Interface entries
					if $set_interface_Address
					then
						interface_Address=("${new_interface_Address[@]}")
					fi
					
					# apply new Peer entries with certain restrictions
					if $set_peer_Type && [ "$new_peer_Type" != "$peer_Type" ]
					then
						if [ "$new_peer_Type" = "client" ]
						then
							# remove Endpoints (a client cannot be reached externally per our definition)
							peer_Endpoint=""
							peer_VirtualEndpoint=""
							# remove any non-128-bitmask addresses
							if ! $set_peer_AllowedIPs
							then
								set_peer_AllowedIPs=true
								new_peer_AllowedIPs=()
								for allowed_ip in "${peer_AllowedIPs[@]}"
								do
									allowed_ip="${allowed_ip%/128}"
									case "$allowed_ip" in
										*/*|*\$[1-9]*) ;; # skip non-128 bitmasks, and addresses with a non-zero cost
										*)
											new_peer_AllowedIPs+=("$allowed_ip/128")
										;;
									esac
								done
							fi
							# remove persistent keepalive as well
							peer_PersistentKeepalive=""
						fi
						
						peer_Type="$new_peer_Type"
					fi
					if $set_peer_Endpoint
					then
						if [ "$peer_Type" = "client" ] && [ -n "$new_peer_Endpoint" ]
						then
							echo "warning: Endpoint not allowed for [Peer] Type = client." >&2
						else
							peer_Endpoint="$new_peer_Endpoint"
						fi
					fi
					if $set_peer_VirtualEndpoint
					then
						if [ "$peer_Type" = "client" ] && [ -n "$new_peer_VirtualEndpoint" ]
						then
							echo "warning: VirtualEndpoint not allowed for [Peer] Type = client." >&2
						else
							peer_VirtualEndpoint="$new_peer_VirtualEndpoint"
						fi
					fi
					if $set_peer_VirtualHostname
					then
						peer_VirtualHostname="$new_peer_VirtualHostname"
					fi
					if $set_peer_AllowedIPs
					then
						peer_AllowedIPs=("${new_peer_AllowedIPs[@]}")
					fi
					if $set_peer_PersistentKeepalive
					then
						if [ "$peer_Type" = "client" ] && [ -n "$new_peer_PersistentKeepalive" ]
						then
							echo "warning: PersistentKeepalive not allowed for [Peer] Type = client."
						else
							peer_PersistentKeepalive="$new_peer_PersistentKeepalive"
						fi
					fi
				fi
				
				print_section_buffer >&$write_fd
			}
			process_eof()
			{
				# if not matched, append new section at the end of the file
				if ! $section_matched
				then
					case "$opts_command" in
						set-interface)
							section="Interface"
						;;
						set-peer)
							section="Peer"
							peer_PublicKey="$1"
						;;
					esac
					
					process_section "$@"
				fi
			}
		;;
		remove-peer)
			process_section()
			{
				if [ "$section" = "Peer" ] && [ "$peer_PublicKey" = "$1" ]
				then
					return 0
				else
					print_section_buffer >&$write_fd
				fi
			}
		;;
		show|'') ;; # do default behavior, which is to print every section
		*)
			echo "error: Invalid conf command ($opts_command)."
			exit 1
		;;
	esac
	
	# ensure existence of conf_file
	(
		umask 077
		touch "$conf_file" || exit 1
	) || exit $?
	
	write_fd=""
	read_fd="200"
	(
		flock -w 10 -e 200 || { echo "error: Failed to flock file ($conf_file)."; exit 1; }
		
		# enable writing, but then read from a swap-file
		# do not write to swap file, because conf-file is already locked, moving swap-file on top of conf-file breaks the flock functionality
		case "$opts_command" in
			set-*|remove-*)
				swap_file="$conf_file.swp"
				cp "$conf_file" "$swap_file"
				
				read_fd=201
				exec 201<"$swap_file" # open for reading

				write_fd=202
				exec 202>"$conf_file" # open for writing, immediately truncates file
		esac
		
		reset_section_values
		
		exitcode=0
		
		while read -r -u "$read_fd" original_line
		do
			case "$original_line" in
				'')
					# skip empty lines
					continue
				;;
				\#*)
					# skip comments
					section_buffer+=("$original_line")
					continue
				;;
				\[*)
					process_section "$@" || exitcode=$?
					
					reset_section_values
					
					section="${original_line%%]*}"
					section="${section##*[}"
					
					continue
				;;
			esac
			
			# strip comments at end of lines
			line="${original_line%%#*}"
			
			# try to parse line
			parsed=false
			case "$section" in
				Interface)
					case "${line// /}" in
						PrivateKey=*)
							parsed=true
							read -r interface_PrivateKey <<<"${line#*=}"
						;;
						Address=*)
							parsed=true
							split ',' "${line#*=}" interface_Address
						;;
						ListenPort=*)
							parsed=true
							read -r interface_ListenPort <<<"${line#*=}"
						;;
						Endpoint=*)
							parsed=true
							read -r interface_Endpoint <<<"${line#*=}"
						;;
						InterfaceID=*)
							parsed=true
							read -r interface_InterfaceID <<<"${line#*=}"
						;;
						PrefixMask=*)
							parsed=true
							read -r interface_PrefixMask <<<"${line#*=}"
						;;
					esac
				;;
				Peer)
					case "${line// /}" in
						Type=*)
							parsed=true
							read -r peer_Type < <(strtolower "${line#*=}")
						;;
						PublicKey=*)
							parsed=true
							read -r peer_PublicKey <<<"${line#*=}"
						;;
						Endpoint=*)
							parsed=true
							read -r peer_Endpoint <<<"${line#*=}"
						;;
						VirtualEndpoint=*)
							parsed=true
							read -r peer_VirtualEndpoint <<<"${line#*=}"
						;;
						VirtualHostname=*)
							parsed=true
							read -r peer_VirtualHostname <<<"${line#*=}"
						;;
						AllowedIPs=*)
							parsed=true
							split ',' "${line#*=}" peer_AllowedIPs
						;;
						PersistentKeepalive=*)
							parsed=true
							read -r peer_PersistentKeepalive <<<"${line#*=}"
						;;
					esac
				;;
			esac
			
			if ! $parsed
			then
				section_buffer+=("$original_line")
			fi
		done
		
		process_section "$@" || exitcode=$?
		
		reset_section_values
		
		process_eof "$@" || exitcode=$?
		
		if [ -n "$write_fd" ]
		then
			exec 201<&-
			exec 202>&-
			
			# if set- or remove- command, replace configuration file with swap file
			rm -f "$swap_file"
		fi
		
		exit $exitcode
		
	) 200<"$conf_file" || exit $?
}

context_protocol()
{
	opts_command="$1"
	shift
	
	case "$opts_command" in
		connect)
			connect_host="$1"
			connect_port="$2"
			
			# support for both host:port and host port in one combined argument or two separate arguments
			if [ -z "$connect_port" ]
			then
				# extract port from host (with IPv6 detection)
				case "$connect_host" in
					\[*\]:*)
						connect_port="${connect_host##*:}"
						connect_host="${connect_host%:*}"
					;;
					*:*:*)
						# IPv6 address without port
					;;
					*:*)
						connect_port="${connect_host##*:}"
						connect_host="${connect_host%:*}"
					;;
				esac
			fi
			
			# if IPv6, wrap IPv6 in square brackets, unless it is already wrapped
			read -r connect_host < <(ensure_ipv6_brackets "$connect_host")
			
			if [ -z "$connect_port" ]
			then
				echo "info: Connecting to: $connect_host... Port defaults to first checking HTTP-port (:80), with fallback at :$WIREGUARD_PORT" >&2
			else
				echo "info: Connecting to: $connect_host:$connect_port..." >&2
			fi
			
			# check which IP-address family to use for socat
			read -r ip_family < <(get_ip_family "$connect_host" "${connect_port:-$WIREGUARD_PORT}")
			
			conn_cmd=(socat -t"$PROTOCOL_TIMEOUT_S" - "${ip_family:-tcp}":"$connect_host":"${connect_port:-$WIREGUARD_PORT}")
			if is_http "$connect_host" "${connect_port:-80}"
			then
				conn_cmd=(curl --data-binary @- --insecure --max-time "$PROTOCOL_TIMEOUT_S" -H 'Connection: close' --fail-with-body --location --user-agent 'wg-autoconf/1.0' "http://$connect_host:${connect_port:-80}/.well-known/wg-autoconf/")
			fi
			
			exec "${conn_cmd[@]}"
		;;
		listen)
			listen_port="${1#:}"
			shift
			if [ "$1" = "execute" ]
			then
				# skip over 'execute' as more readable call
				shift
			fi
			
			read -r opts_bind_host < <(ensure_ipv6_brackets "$opts_bind_host")
			
			tcp_listen="tcp-listen"
			if [ "${opts_bind_host:0:1}" = "[" ]
			then
				tcp_listen="tcp6-listen"
			fi
			
			if ! is_num "$listen_port"
			then
				echo "error: Invalid listen port ($listen_port). Check configuration." >&2
				exit 1
			fi
			
			socat -t"$PROTOCOL_TIMEOUT_S" "$tcp_listen":"$listen_port",bind="$opts_bind_host",reuseaddr,fork system:"$0 $opts_interface protocol accept $*"
		;;
		accept)
			# wrap HTTP if client is detected to use HTTP
			line=""
			
			if read -r line
			then
				read http_method http_path http_version <<<"$line"
				
				case "$http_method" in
					GET|POST)
						echo -en "HTTP/1.1 200 OK\r\n"
						echo -en "Content-Type: text/plain\r\n"
						echo -en "Connection: close\r\n"
						echo -en "Cache-Control: no-store, max-age=0\r\n"
						echo -en "\r\n"
					;;
				esac
			fi
			
			# kill -SIGINT 0 stops cat when $@ is done executing, 0 refers to the process group that the pipeline is in
			# set -m is to enable job control (new process groups), to ensure socat listening instance is not killed

			set -m
			{ echo "$line"; cat; } | { "$@"; kill -SIGINT 0; }
		;;
	esac
	
}

context_client()
{
	opts_command="$1"
	shift
	
	conf_file="/etc/wireguard/$opts_interface.conf"
	
	read -r local_PrivateKey < <("$0" "$opts_interface" conf get-interface PrivateKey)
	
	# generate new PrivateKey if missing
	if [ -z "$local_PrivateKey" ]
	then
		echo "info: Generating private key..."
		read -r local_PrivateKey < <("$0" "$opts_interface" genkey)
		
		if [ -z "$local_PrivateKey" ]
		then
			echo "error: Failed to generate a private key ($0 genkey)."
			exit 1
		fi
		
		echo "info: Missing private key generated."
		
		# note: pass through stdin, to avoid leaking PrivateKey in process list
		"$0" "$opts_interface" conf set-interface <<EOF
PrivateKey = $local_PrivateKey
EOF
	fi
	
	read -r local_PublicKey < <("$0" "$opts_interface" pubkey <<<"$local_PrivateKey")
	
	case "$opts_command" in
		connect)
			connect_host="$1"
			connect_port="$2"
			
			if [ -n "$opts_mac_address" ] && [ "$opts_mac_address" != "auto" ]
			then
				# set a custom InterfaceID, as per command-line options (it must be hexadecimal)
				
				local_InterfaceID="$opts_mac_address"
				
			else
				# try to read from cache
				read -r local_InterfaceID _ < <("$0" "$opts_interface" conf get-interface InterfaceID) || true
				
				# automatically determine MAC-address based on available network links
				if [ -z "$local_InterfaceID" ]
				then
					# try the first default route
					read -r _ _ _ _ default_dev _ < <(ip route show default) # parse: _default _via _address _dev <default_dev> _...
					[ -z "$default_dev" ] || read -r local_InterfaceID _ < <(cat /sys/class/net/"$default_dev"/address 2>/dev/null) || true
					
					# then try any available link
					[ -n "$local_InterfaceID" ] || read -r local_InterfaceID _ < <(cat /sys/class/net/*/address 2>/dev/null) || true
					
					# cache this automatically determined MAC-address for consistent re-use in the future (in case network link is unplugged next reconnect)
					if [ -n "$local_InterfaceID" ]
					then
						if "$0" "$opts_interface" conf set-interface <<EOF
InterfaceID = $local_InterfaceID
EOF
						then
							echo "info: InterfaceID ($local_InterfaceID) saved to configuration file."
						else
							echo "warning: Failed to save InterfaceID."
						fi
					else
						echo "error: Failed to "
					fi
				fi
			fi
			
			# use local hostname
			read -r local_VirtualHostname < <(hostname)
			
			echo "info: Local public key: $local_PublicKey"
			
			remote_PublicKey=""
			remote_ListenPort=""
			remote_Address=()
			remote_Endpoint=""
			remote_PrefixMask=""
			
			client_Address=""
			
			section=""
			while read -r line || { socat_exit_code="$line" && break; }
			do
				sock_receive "$line"
				
				# parse section name
				case "$line" in
					\[*)
						section="${line%%]*}"
						section="${section##*[}"
						continue
					;;
				esac
				
				# parse section body
				case "${line// /}" in
					Error=*)
						read -r remote_err <<<"${line#*=}"
						echo "error: Server responded with error: $remote_err"
						exit 1
					;;
				esac
				case "$section" in
					Interface)
						case "${line// /}" in
							PublicKey=*)
								read -r remote_PublicKey <<<"${line#*=}"
							;;
							Address=*)
								split ',' "${line#*=}" remote_Address
							;;
							ListenPort=*)
								read -r remote_ListenPort <<<"${line#*=}"
							;;
							Endpoint=*)
								read -r remote_Endpoint <<<"${line#*=}"
							;;
							PrefixMask=*)
								read -r remote_PrefixMask <<<"${line#*=}"
							;;
						esac
					;;
					Peer)
						case "${line// /}" in
							AllowedIPs=*)
								read -r client_Address <<<"${line#*=}"
							;;
						esac
					;;
				esac
			done < <("$0" "$opts_interface" protocol connect "$connect_host" "$connect_port" < <(
					sock_send "[Peer]"
					sock_send "Type = client"
					sock_send "PublicKey = $local_PublicKey"
					[ -z "$local_InterfaceID" ] || sock_send "InterfaceID = $local_InterfaceID"
					[ -z "$local_VirtualHostname" ] || sock_send "VirtualHostname = $local_VirtualHostname"
					sock_send ""
				)
				echo -n "$?"
			)
			
			if [ "$socat_exit_code" -ne 0 ]
			then
				echo "error: Connection failure ($socat_exit_code)."
				exit 1
			fi
			
			if [ -z "$client_Address" ]
			then
				echo "error: Did not receive AllowedIPs from server. Is the client ($local_PublicKey) authorized?"
				echo "note: The server may authorize this client using: wg-autoconf server allow '$local_PublicKey'"
				exit 1
			fi
			
			# fix ListenPort
			[ -z "$remote_ListenPort" ] || remote_ListenPort="$connect_port"
			
			# fix Endpoint to be complete with ListenPort
			if [ -n "$remote_Endpoint" ]
			then
				# add missing square brackets to a loose IPv6 address (without port)
				read -r remote_Endpoint < <(ensure_ipv6_brackets "$remote_Endpoint")
				
				# add missing port argument
				case "$remote_Endpoint" in
					\[*\]) # is ipv6-address
						remote_Endpoint="$remote_Endpoint:$remote_ListenPort"
					;;
					*:*) ;; # is host:port definition
					*)
						remote_Endpoint="$remote_Endpoint:$remote_ListenPort"
					;;
				esac
				
				# override Endpoint with the server settings
				remote_Endpoint="$remote_Endpoint"
			else
				# set to same hostname as used to connect, and add port explicitly
				remote_Endpoint="$connect_host:$remote_ListenPort"
			fi
			
			# combine remote_Address to one line:
			read -r remote_AddressLine < <(join ', ' "${remote_Address[@]}")
			
			echo "info: Configuration received from server ($remote_PublicKey)."
			
			echo "info: Client address: $client_Address"
			
			[ -z "$remote_AddressLine" ] || echo "info: Server virtual addresses: $remote_AddressLine"
			
			echo "info: Server is reachable at: $remote_Endpoint"
			
			if ! "$0" "$opts_interface" conf set-interface <<EOF
Address = $client_Address
PrefixMask = $remote_PrefixMask
EOF
			then
				echo "error: Failed to update configuration (set-interface)."
				exit 1
			fi
			
			# the client only has one target endpoint, by definition, this keeps the configuration file simple and small
			# and automatically avoids conflicts with AllowedIPs (possibly with same prefix and potentially different masks)
			# multiple connections should be possible though
			while read -r cur_PublicKey
			do
				# unless the PublicKey is the same, because in that case, the configuration is to be overwritten already
				if [ "$cur_PublicKey" != "$remote_PublicKey" ]
				then
					# delete any other existing server
					echo "info: Removing peer ($cur_PublicKey) with configuration:"
					"$0" "$opts_interface" conf get-peer "$cur_PublicKey"
					"$0" "$opts_interface" conf remove-peer "$cur_PublicKey"
				fi
				
			done < <("$0" "$opts_interface" conf list-servers PublicKey)
			
			if ! "$0" "$opts_interface" conf set-peer "$remote_PublicKey" <<EOF
Type = server
AllowedIPs = $remote_AddressLine
Endpoint = $remote_Endpoint
PersistentKeepalive = $opts_persistent_keepalive_s
EOF
			then
				echo "error: Failed to update configuration (set-peer)."
				exit 1
			fi
			
			"$0" "$opts_interface" up "$opts_interface"
			
			# keep script alive, while handshakes are going on, this could also just be a separate command:
			# wg-autoconf client monitor
			if [ "$opts_alive_count_max" -gt 0 ] && [ "$opts_persistent_keepalive_s" -gt 0 ]
			then
				resolved_endpoint=""
				# strip port
				remote_hostname="${remote_Endpoint%:*}"
				# strip IPv6 brackets
				remote_hostname="${remote_hostname#\[}"
				remote_hostname="${remote_hostname%\]}"
				
				if is_hostname "$remote_hostname"
				then
					# get resolved IP-address
					read -r resolved_endpoint < <("$0" "$opts_interface" show "$opts_interface" endpoints | awk '$1=="'"$remote_PublicKey"'"{print $2}')
					
					echo "info: Connected to resolved endpoint: $resolved_endpoint"
					
					# strip port
					resolved_endpoint="${resolved_endpoint%:*}"
					# strip IPv6 brackets
					resolved_endpoint="${resolved_endpoint#\[}"
					resolved_endpoint="${resolved_endpoint%\]}"
				fi
				
				# note: Handshake is only done every once per 120 seconds (as per Wireguard protocol).
				#       Therefore, if we allow 1 missed handshake, the minimum timeout with a PersistentKeepalive of 25 seconds, is 145 seconds (= 120 + 45).
				#       Since we only check when the last handshake is, and we don't actually use the tunnel.
				#       This is really a failsafe method to detect a bad connection, which catches any kind of connection loss, but takes a long time to detect.
				#       If a server must be brought down, the correct procedure is to remove it from the DNS round robin first, which is detected here every PersistentKeepalive seconds.
				#       However, DNS is also slow, it may take many minutes if not hours, to propagate such a change.
				
				# TODO: use a local BIND service with max-stale-ttl and stale-answer-enable options, for redundancy in case of nameserver downtime of the remote hostname Endpoint
				
				handshake_timeout_s="$((opts_alive_count_max * opts_persistent_keepalive_s + 120))"
				
				last_confirmed_handshake=""
				while true
				do
					# if the remote Endpoint is a hostname,  check if it still resolves to the IP-address of the remote Endpoint
					if [ -n "$resolved_endpoint" ] && ! getent hosts "$remote_hostname" | grep -F "$resolved_endpoint" >/dev/null 2>/dev/null && ! getent ahosts "$remote_hostname" | grep -F "$resolved_endpoint" >/dev/null 2>/dev/null
					then
						echo "error: Endpoint IP-address ($resolved_endpoint) is not listed by the DNS records of the remote hostname anymore ($remote_hostname)."
						exit 78
					fi
					
					# check last handshake connection
					read -r last_handshake < <("$0" "$opts_interface" show "$opts_interface" latest-handshakes | awk '$1=="'"$remote_PublicKey"'"{print $2}')
					read -r cur_time < <(date +'%s')
					if [ -n "$last_handshake" ] && [ "$last_handshake" -gt 0 ]
					then
						last_confirmed_handshake="$last_handshake"
						
					elif [ -z "$last_confirmed_handshake" ]
					then
						last_confirmed_handshake="$cur_time"
					fi
					
					delta_time_s=$((cur_time - last_confirmed_handshake))
					
					if [ "$delta_time_s" -gt "$handshake_timeout_s" ]
					then
						echo "error: Connection timeout ($last_handshake is more than $handshake_timeout_s seconds ago)."
						exit 110
					fi
					
					echo "debug: Last handshake $delta_time_s seconds ago, less than the timeout of $handshake_timeout_s seconds. Waiting for next handshake."
					
					# sleep, plus one second margin
					sleep "$((opts_persistent_keepalive_s - delta_time_s % opts_persistent_keepalive_s + 1))"
				done
			fi
		;;
		*)
			echo "error: Invalid client command ($opts_command)." >&2
			exit 1
		;;
	esac
}


context_server()
{
	opts_command="$1"
	shift
	
	case "$opts_command" in
		allow)
			if ! "$0" "$opts_interface" conf set-peer "$@"
			then
				echo "error: Failed to allow peer (conf $conf_cmd)."
				exit 1
			fi
			
			if ! "$0" "$opts_interface" update "$opts_interface"
			then
				echo "error: Failed to allow peer (update)."
				exit 1
			fi
			
			echo "info: Peer is now allowed access."
			exit 0
		;;
		deny)
			if ! "$0" "$opts_interface" conf remove-peer "$@"
			then
				echo "error: Failed to deny peer (conf remove-peer)."
				exit 1
			fi
			
			if ! "$0" "$opts_interface" update "$opts_interface"
			then
				echo "error: Failed to deny peer (update)."
				exit 1
			fi
			
			echo "info: Peer is now denied access."
			exit 0
		;;
	esac
	
	
	# grab local_PrivateKey
	local_PrivateKey="$("$0" "$opts_interface" conf get-interface PrivateKey)"
	
	
	# generate new PrivateKey if missing
	if [ -z "$local_PrivateKey" ]
	then
		echo "info: Generating private key..."
		local_PrivateKey="$("$0" "$opts_interface" genkey)"
		
		if [ -z "$local_PrivateKey" ]
		then
			echo "error: Failed to generate a private key ($0 genkey)."
			exit 1
		fi
		
		echo "info: Missing private key generated."
		
		# note: pass through stdin to avoid leaking PrivateKey in the process list
		"$0" "$opts_interface" conf set-interface <<EOF
PrivateKey = $local_PrivateKey
EOF
	fi
	
	
	# grab local_PublicKey (extract from private key)
	local_PublicKey="$("$0" "$opts_interface" pubkey <<<"$local_PrivateKey")"
	
	
	# grab local_Address value and generate local_AddressLine
	local_Address=()
	while read -r address
	do
		local_Address+=("$address")
		
	done < <("$0" "$opts_interface" conf get-interface Address)
	
	local_AddressLine=""
	if [ -n "$opts_vpn_address" ] || [ "${#local_Address[@]}" -eq 0 ]
	then
		local_AddressLine="${opts_vpn_address:-$DEFAULT_VPN_ADDRESS}"
		local_Address=()
		split ',' "${local_AddressLine#*=}" local_Address
		
		echo "info: Updating Address in Interface-section."
		
		"$0" "$opts_interface" conf set-interface <<EOF
Address = $local_AddressLine
EOF
	else
		read -r local_AddressLine < <(join ',' "${local_Address[@]}")
	fi
	
	
	# grab local_ListenPort (and set local_ListenPort_configured)
	read -r local_ListenPort < <("$0" "$opts_interface" conf get-interface ListenPort)
	[ -n "$local_ListenPort" ] && local_ListenPort_configured=true || local_ListenPort_configured=false
	[ -n "$local_ListenPort" ] || read -r local_ListenPort < <("$0" "$opts_interface" show "$opts_interface" listen-port)
	[ -n "$local_ListenPort" ] || local_ListenPort="$WIREGUARD_PORT"
	
	# grab local_Endpoint
	read -r local_Endpoint < <("$0" "$opts_interface" conf get-interface Endpoint)
	
	# fallback to current hostname (this is probably the best default behavior that should not be stored in the configuration file explicitly unless done so manually)
	[ -n "$local_Endpoint" ] || read -r local_Endpoint < <(hostname)

	# if Endpoint is set, add port to it, because it is mandatory to have a port in the [Peer]-section that we'll send
	public_Endpoint=""
	if [ -n "$local_Endpoint" ]
	then
		# add missing square brackets to a loose IPv6 address (without port)
		read -r public_Endpoint < <(ensure_ipv6_brackets "$local_Endpoint")
		
		# add missing port argument (an Endpoint and ServerEndpoint in [Peer] must have a port, however, in the [Interface]-section it should be left out, since ListenPort must be set to the same port anyway)
		case "$public_Endpoint" in
			\[*\]) # is ipv6-address
				public_Endpoint="$public_Endpoint:$local_ListenPort"
			;;
			*:*) ;; # is host:port definition
			*)
				public_Endpoint="$public_Endpoint:$local_ListenPort"
			;;
		esac
	fi
	
	# grab local_PrefixMask
	read -r local_PrefixMask < <("$0" "$opts_interface" conf get-interface PrefixMask) || true
	[ -n "$local_PrefixMask" ] || local_PrefixMask="$DEFAULT_VPN_PREFIX_MASK"
	
	case "$opts_command" in
		get-public-key)
			echo "$local_PublicKey"
		;;
		get-public-endpoint)
			echo "$public_Endpoint"
		;;
		list-virtual-endpoints)
			# print VirtualEndpoint of each server
			# if missing, print the AllowedIPs first value, with the port of Endpoint, which is a good default value
			# this kind of message, can also allow one server to update the configuration of another server
			# except the AllowedIPs is allowed to be set the first time, through the public Endpoint, to allow for initial connection
			
			# list virtual endpoints, that is just the first AllowedIPs for each public key, with the Endpoint's port
			server_PublicKey=""
			server_VirtualEndpoint=""
			server_FirstAllowedIP=""
			server_Endpoint=""
			
			print_server()
			{
				if [ -z "$server_VirtualEndpoint" ]
				then
					server_VirtualEndpoint="${server_FirstAllowedIP%%/*}"
					server_VirtualEndpoint="${server_VirtualEndpoint%%\$*}"
					read -r server_VirtualEndpoint < <(ensure_ipv6_brackets "$server_VirtualEndpoint")
					
					virtual_port=""
					case "$server_Endpoint" in
						\[*\]:*)
							virtual_port="${server_Endpoint##*:}"
						;;
						*:*:*)
							# IPv6 address without port
						;;
						*:*)
							virtual_port="${server_Endpoint##*:}"
						;;
					esac
					if [ -n "$virtual_port" ]
					then
						server_VirtualEndpoint="${server_VirtualEndpoint}:${virtual_port}"
					fi
				fi
				
				if [ -n "$server_VirtualEndpoint" ]
				then
					echo -e "$server_PublicKey\t$server_VirtualEndpoint"
				fi
			}
			
			section=""
			while read -r line
			do
				# grab the VirtualEndpoint
				# if not exists, we should print instead the first AllowedIPs line
				# with the port of Endpoint (or leave out if no port defined there)
				
				# parse section name
				case "$line" in
					\[*)
						section="${line%%]*}"
						section="${section##*[}"
						
						print_server
						
						server_PublicKey=""
						server_VirtualEndpoint=""
						server_FirstAllowedIP=""
						server_Endpoint=""
						continue
					;;
				esac
				
				case "$section" in
					Peer)
						case "${line// /}" in
							PublicKey=*)
								read -r server_PublicKey <<<"${line#*=}"
							;;
							VirtualEndpoint=*)
								read -r server_VirtualEndpoint <<<"${line#*=}"
							;;
							AllowedIPs=*)
								if [ -z "$server_FirstAllowedIP" ]
								then
									read -r server_FirstAllowedIP <<<"${line#*=}"
								fi
							;;
							Endpoint=*)
								read -r server_Endpoint <<<"${line#*=}"
							;;
						esac
					;;
				esac
				
			done < <("$0" "$opts_interface" conf list-servers)
			
			print_server
		;;
		send-message)
			# send a message to a server in the pool, given by the host
			# address must include both host and port
			target_address="$1"
			
			"$0" "$opts_interface" protocol connect "$target_address" <<EOF
Type=server
PublicKey=$local_PublicKey
Message=$2
Data=$3

EOF
		;;
		connect)
			connect_host="$1"
			connect_port="$2"
			
			# support for both host:port and host port in one combined argument or two separate arguments
			if [ -z "$connect_port" ]
			then
				# extract port from host (with IPv6 detection)
				case "$connect_host" in
					\[*\]:*)
						connect_port="${connect_host##*:}"
						connect_host="${connect_host%:*}"
					;;
					*:*:*)
						# IPv6 address without port
					;;
					*:*)
						connect_port="${connect_host##*:}"
						connect_host="${connect_host%:*}"
					;;
				esac
			fi
			if [ -z "$connect_port" ]
			then
				connect_port="$WIREGUARD_PORT"
			fi
			
			# if IPv6, wrap IPv6 in square brackets, unless it is already wrapped
			read -r connect_host < <(ensure_ipv6_brackets "$connect_host")
			
			echo "info: Connecting to: $connect_host:$connect_port..."
			
			# determine local address prefixed subnet mask
			local_Address=()
			while read -r address
			do
				local_Address+=("$address")
				
			done < <("$0" "$opts_interface" conf get-interface Address)
			
			# add AllowedIPs from servers open for relay to local_Address, but with an increased cost
			
			# one IP per line, multiple lines may belong to one peer
			while read -r pubkey address
			do
				[ -n "$address" ] || continue
				
				# AllowedIPs may contain cost ($), apply the cost as a metric to the ip -6 route
				relay_cost="0"
				case "$address" in
					*\$*)
						relay_ip="${address%\$*}"
						relay_cost="${address#*\$}"
						[ -n "$relay_cost" ] || relay_cost="0"
					;;
				esac
				# increase relay cost for once, since this is a server
				relay_cost="$((relay_cost + 1))"
				
				local_Address+=("${address%\$*}\$$relay_cost")
				
			done < <("$0" "$opts_interface" conf list-servers AllowedIPs)
			
			read -r local_AddressLine < <(join ', ' "${local_Address[@]}")
			
			# fallback to opts
			[ "${#local_Address[@]}" -ne 0 ] || local_Address=("$opts_vpn_address")
			
			# give PublicKey, telling how to securely connect with us
			# give Endpoint, telling how to reach us
			# give Address, telling which IP-address ranges we are responsible for (using a subnet mask), including metric cost for each relay
			
			remote_PublicKey=""
			remote_Address=()
			remote_ListenPort=""
			remote_Endpoint=""
			remote_PrefixMask=""
			
			assigned_Address=()
			
			# check which IP-address family to use for socat
			read -r ip_family < <(get_ip_family "$connect_host" "$connect_port")
			
			conn_cmd=(socat -t"$PROTOCOL_TIMEOUT_S" - "${ip_family:-tcp}":"$connect_host":"$connect_port")
			if is_http "$connect_host" "$connect_port"
			then
				conn_cmd=(curl --data-binary @- --insecure --max-time "$PROTOCOL_TIMEOUT_S" -H 'Connection: close' --fail-with-body --location --user-agent 'wg-autoconf/1.0' "http://$connect_host:$connect_port/.well-known/wg-autoconf/")
			fi
			
			section=""
			while read -r line || { socat_exit_code="$line" && break; }
			do
				sock_receive "$line"
				
				# parse section name
				case "$line" in
					\[*)
						section="${line%%]*}"
						section="${section##*[}"
						continue
					;;
				esac
				
				# parse section body
				case "${line// /}" in
					Error=*)
						read -r remote_err <<<"${line#*=}"
						echo "error: Server responded with error: $remote_err"
						exit 1
					;;
				esac
				case "$section" in
					Interface)
						case "${line// /}" in
							PublicKey=*)
								read -r remote_PublicKey <<<"${line#*=}"
							;;
							Address=*)
								split ',' "${line#*=}" remote_Address
							;;
							ListenPort=*)
								read -r remote_ListenPort <<<"${line#*=}"
							;;
							Endpoint=*)
								read -r remote_Endpoint <<<"${line#*=}"
							;;
							PrefixMask=*)
								read -r remote_PrefixMask <<<"${line#*=}"
							;;
						esac
					;;
					Peer)
						case "${line// /}" in
							AllowedIPs=*)
								split ',' "${line#*=}" assigned_Address
							;;
						esac
					;;
				esac
				
			done < <("${conn_cmd[@]}" < <(
					
					sock_send "[Peer]"
					sock_send "Type = Server"
					sock_send "PublicKey = $local_PublicKey"
					sock_send "Address = $local_AddressLine"
					sock_send "Endpoint = $public_Endpoint"
					sock_send "PrefixMask = $local_PrefixMask"
					sock_send ""
				); echo -n "$?")
			
			if [ "$socat_exit_code" -ne 0 ]
			then
				echo "error: Connection failure ($socat_exit_code)."
				exit 1
			fi
			
			if [ -z "$remote_PrefixMask" ]
			then
				echo "note: Remote server has no explicitly defined PrefixMask, defaulting to $DEFAULT_VPN_PREFIX_MASK."
				remote_PrefixMask="$DEFAULT_VPN_PREFIX_MASK"
			fi
			
			if [ "$local_PrefixMask" != "$remote_PrefixMask" ]
			then
				echo "error: Remote PrefixMask ($remote_PrefixMask) does not match the local PrefixMask ($local_PrefixMask)."
				echo "note: To match the remote server configuration, run: $0 conf set-interface PrefixMask=$remote_PrefixMask"
				exit 1
			fi
			
			assigned_PrimaryAddress="${assigned_Address[0]}"
			assigned_PrimaryAddress="${assigned_PrimaryAddress%/*}/128"
			
			# combine server_Address to one line:
			read -r assigned_AddressLine < <(join ', ' "${assigned_Address[@]}")
			
			if [ -z "$assigned_AddressLine" ]
			then
				echo "error: Did not receive AllowedIPs from remote server. Is the local server ($local_PublicKey) authorized?"
				echo "note: The remote server may authorize this local server using: $0 server allow '$local_PublicKey' <<<'Type=server'"
				exit 1
			fi
			
			# filter our own local address from remote address, as it might be contained by remote address since it could be a relay for us
			# this would create a loop, so that is avoided here
			filtered_remote_Address=()
			while read -r address
			do
				filtered_remote_Address+=("$address")
				
			done < <(grep -Fvxf <(join $'\n' "${local_Address[@]}") <(join $'\n' "${remote_Address[@]}"))
			remote_Address=("${filtered_remote_Address[@]}")
			
			remote_PrimaryAddress="${remote_Address[0]}"
			remote_PrimaryAddress="${remote_PrimaryAddress%/*}/128"
			
			# combine server_Address to one line:
			read -r remote_AddressLine < <(join ', ' "${remote_Address[@]}")
			
			echo "info: Remote server (PublicKey = $remote_PublicKey) can now reach this local server at: $local_ServerEndpoint"
			echo "info: Received virtual IP-address assignment: $assigned_AddressLine"
			
			# add the server's remote Endpoint as connect_host overwrite, and set as Endpoint fo the new [Peer]-section
			[ -n "$remote_ListenPort" ] || remote_ListenPort="$connect_port"
			
			# fix Endpoint to be complete with ListenPort
			if [ -n "$remote_Endpoint" ]
			then
				# add missing square brackets to a loose IPv6 address (without port)
				read -r remote_Endpoint < <(ensure_ipv6_brackets "$remote_Endpoint")
				
				# add missing port argument
				case "$remote_Endpoint" in
					\[*\]) # is ipv6-address
						remote_Endpoint="$remote_Endpoint:$remote_ListenPort"
					;;
					*:*) ;; # is host:port definition
					*)
						remote_Endpoint="$remote_Endpoint:$remote_ListenPort"
					;;
				esac
				
				# override Endpoint with the server settings
				remote_Endpoint="$remote_Endpoint"
			else
				# set to same hostname as used to connect, and add port explicitly
				remote_Endpoint="$connect_host:$remote_ListenPort"
			fi
			
			if "$0" "$opts_interface" conf set-peer "$remote_PublicKey" <<EOF
[Peer]
Type = server
AllowedIPs = $remote_AddressLine
Endpoint = $remote_Endpoint
EOF
			then
				echo "info: Success."
			else
				echo "error: Failed to update configuration ($0 $opts_interface conf set-peer $remote_PublicKey)."
				exit 1
			fi
			
			"$0" "$opts_interface" up "$opts_interface"
			
			"$0" "$opts_interface" show "$opts_interface"
		;;
		listen)
			set -e # exit on any failure
			
			read -r opts_bind_host < <(ensure_ipv6_brackets "$opts_bind_host")
			listen_port="${1#:}"
			
			if [ -n "$listen_port" ] && [ "$listen_port" != "$local_ListenPort" ] || ! $local_ListenPort_configured
			then
				local_ListenPort="${listen_port:-$WIREGUARD_PORT}"
				
				echo "info: Updating ListenPort in Interface-section."
				if "$0" "$opts_interface" conf set-interface <<EOF
ListenPort = $local_ListenPort
EOF
				then
					local_ListenPort_configured=true
				else
					exit 1
				fi
			fi
			
			if [ -n "$opts_prefix_mask" ] && [ "$opts_prefix_mask" != "$local_PrefixMask" ]
			then
				# specified a custom PrefixMask in the configuration
				local_PrefixMask="$opts_prefix_mask"
				
				echo "info: Updating PrefixMask in Interface-section."
				
				"$0" "$opts_interface" conf set-interface <<EOF
PrefixMask = $local_PrefixMask
EOF
			fi
			
			"$0" "$opts_interface" up "$opts_interface"
			
			echo "Listening on $opts_bind_host:$local_ListenPort with public key: $local_PublicKey"
			
			cmd=("$0")
			for ((i=1;i<opts_verbosity;i++))
			do
				cmd+=("-v")
			done
			cmd+=("-k" "$opts_persistent_keepalive_s")
			cmd+=("'$opts_interface'")
			cmd+=("server" "accept" "'$local_PublicKey'")
			
			tcp_listen="tcp-listen"
			if [ "${opts_bind_host:0:1}" = "[" ]
			then
				tcp_listen="tcp6-listen"
			fi
			
			if ! is_num "$local_ListenPort"
			then
				echo "error: Invalid listen port (ListenPort = $local_ListenPort). Check configuration."
				exit 1
			fi

			emit_server_event "$opts_interface" "listening" "$opts_bind_host" "$local_ListenPort"
			
			"$0" --bind "$opts_bind_host" "$opts_interface" protocol listen "$local_ListenPort" execute "${cmd[*]}"
		;;
		accept)
			local_PublicKey="$1"
			read -r sock_addr < <(expand_ipv6 "$SOCAT_PEERADDR")
			
			[ "$opts_verbosity" -ge 1 ] && echo "info: Remote[]: Connected." >&2
			[ "$opts_verbosity" -ge 1 ] && trap 'echo "info: Remote[$remote_PublicKey]: Disconnected." >&2' EXIT
			
			# peer can send:
			remote_PublicKey=""      # the remote Peer's PublicKey (mandatory)
			remote_Type=""           # remote Type: client or server (optional), defaults to client
			remote_Message=""        # trigger a certain message notification (only if peer_Type is found to be "server"), and the connection is through the local virtual network, and the IP-address matches
			remote_Data=""
			# in case of client:
			remote_InterfaceID=""     # the MAC-address or some other preferred unique identifier of this client (optional)
			remote_VirtualHostname="" # the hostname that this device identifies itself by, server may or may not use this (optional)
			# in case of server:
			remote_Address=()         # how to reach the server directly, and a mask specifying which clients it can also support, and $[0-9]+ for a cost metric for relaying servers (mandatory)
			remote_Endpoint=""        # how to reach this server from outside (optional, but sort of mandatory if server, otherwise the connection is only half)
			remote_VirtualEndpoint="" # how to reach this server from inside the tunnel
			remote_PrefixMask=""      # ensure the remote PrefixMask matches the local PrefixMask, otherwise no connection should occur
			set_remote_Endpoint=false
			set_remote_VirtualEndpoint=false
			
			# initially we set the (long) default protocol timeout, after receiving PublicKey, we set a shorter timeout when the first empty line is received
			client_timeout_s="$PROTOCOL_TIMEOUT_S"
			
			while read -t "$client_timeout_s" -r line
			do
				sock_receive "$line"
				
				case "${line// /}" in
					PublicKey=*)
						read -r remote_PublicKey <<<"${line#*=}"
					;;
					Type=*)
						read -r remote_Type < <(strtolower "${line#*=}")
					;;
					InterfaceID=*)
						read -r remote_InterfaceID <<<"${line#*=}"
					;;
					Address=*)
						split ',' "${line#*=}" remote_Address
					;;
					Endpoint=*)
						set_remote_Endpoint=true
						read -r remote_Endpoint <<<"${line#*=}"
					;;
					VirtualEndpoint=*)
						set_remote_VirtualEndpoint=true
						read -r remote_VirtualEndpoint <<<"${line#*=}"
					;;
					VirtualHostname=*)
						read -r remote_VirtualHostname <<<"${line#*=}"
					;;
					PrefixMask=*)
						read -r remote_PrefixMask <<<"${line#*=}"
					;;
					Message=*)
						read -r remote_Message <<< "${line#*=}"
					;;
					Data=*)
						read -r remote_Data <<< "${line#*=}"
					;;
					'')
						# the first empty line, while the mandatory PublicKey is already provided, means that the protocol timeout will be set to a very short time
						if [ -n "$remote_PublicKey" ]
						then
							# after 1 second it already times out, just so that client doesn't necessarily need to close stdin before server can continue
							client_timeout_s="1"
						fi
					;;
				esac
				
			done # read from stdin, client must close stdin before server can continue (that is to half-close socket on their end)
			
			if [ -z "$remote_PublicKey" ]
			then
				echo "warn: Remote[$remote_PublicKey]: Bad protocol. PublicKey not given." >&2
				sock_send "Error = 401 Unauthorized (no PublicKey in request)"
				sock_send ""
				if [ "$remote_Type" = "server" ]
				then
					emit_server_event "$opts_interface" "server-rejected" "" "401" "Unauthorized (no PublicKey in request)" >&2
				else
					emit_server_event "$opts_interface" "client-rejected" "" "401" "Unauthorized (no PublicKey in request)" >&2
				fi
				exit 41
			fi
			
			# send information about this server's wireguard configuration to the client socket (stdout):
			interface_block=("[Interface]")
			interface_block+=("PublicKey = $local_PublicKey")
			
			# print ListenPort if it exists (it should exist, otherwise that is a warning, how can a client expect to guess the ListenPort if it is dynamic or unknown)
			[ -z "$local_ListenPort" ] || interface_block+=("ListenPort = $local_ListenPort")
			
			# grab Endpoint and print if exists, it should be the public address of this server, possibly DNS with round-robin
			[ -z "$public_Endpoint" ] || interface_block+=("Endpoint = $public_Endpoint")
			
			# show the PrefixMask
			interface_block+=("PrefixMask = $local_PrefixMask")
			
			# get peer section
			if ! peer_info="$("$0" "$opts_interface" conf get-peer "$remote_PublicKey")"
			then
				# Peer is not authorized
				echo "warn: Remote[$remote_PublicKey]: Not authorized (PublicKey = $remote_PublicKey). To authorize, run: $0 server allow $remote_PublicKey" >&2
				sock_send "Error = 403 Forbidden"
				sock_send_lines "${interface_block[@]}"
				sock_send ""
				if [ "$remote_Type" = "server" ]
				then
					emit_server_event "$opts_interface" "server-rejected" "$remote_PublicKey" "403" "Forbidden" >&2
				else
					emit_server_event "$opts_interface" "client-rejected" "$remote_PublicKey" "403" "Forbidden" >&2
				fi
				exit 43
			fi
			
			# parse [Peer]-section from configuration
			peer_Type=""
			peer_AllowedIPs=()
			peer_Endpoint=""
			peer_VirtualEndpoint=""
			peer_VirtualHostname=""
			peer_PersistentKeepalive=""
			
			while read -r line
			do
				# trim comments
				line="${line%%#*}"
				
				case "${line// /}" in
					Type=*)
						read -r peer_Type < <(strtolower "${line#*=}")
					;;
					Endpoint=*)
						read -r peer_Endpoint <<<"${line#*=}"
						
						# autodetected server-type, but don't overwrite if already set
						[ -z "$peer_Endpoint" ] || [ -n "$peer_Type" ] || peer_Type="server"
					;;
					VirtualEndpoint=*)
						read -r peer_VirtualEndpoint <<<"${line#*=}"
						
						# autodetected server-type, but don't overwrite if already set
						[ -z "$peer_VirtualEndpoint" ] || [ -n "$peer_Type" ] || peer_Type="server"
					;;
					VirtualHostname=*)
						read -r peer_VirtualHostname <<<"${line#*=}"
					;;
					AllowedIPs=*)
						split ',' "${line#*=}" peer_AllowedIPs
						
						# autodetect server-type, but don't overwrite if already set
						case "${peer_AllowedIPs[${#peer_AllowedIPs[@]}]}" in
							*/128) ;;
							*/*) [ -n "$peer_Type" ] || peer_Type="server"
						esac
					;;
					PersistentKeepalive=*)
						read -r peer_PersistentKeepalive <<<"${line#*=}"
					;;
				esac
			done <<<"$peer_info"
			
			# check if peer_AllowedIPs matches the address from which this socket is coming from
			# that means, that sock_authenticated will be true, if the virtual address matches
			sock_authenticated=false
			if [ "$sock_addr" = "0000:0000:0000:0000:0000:ffff:7f00:0001" ] || [ "$sock_addr" = "127.0.0.1" ]
			then
				# this is :ffff:127.0.0.1 (the local loopback address)
				sock_authenticated=true
			else
				for allowed_ip in "${peer_AllowedIPs[@]}"
				do
					allowed_ip="${allowed_ip%%/*}"
					allowed_ip="${allowed_ip%%\$*}"
					read -r norm_allowed_ip < <(expand_ipv6 "$allowed_ip")
					
					if [ "$norm_allowed_ip" = "$sock_addr" ]
					then
						# check if the allowed_ip matches the sock_addr, if so, then sock_authenticated=true
						sock_authenticated=true
					fi
				done
			fi
			
			if [ -n "$remote_Message" ]
			then
				if $sock_authenticated
				then
					echo "info: Remote[$remote_PublicKey]: Received message from ${peer_Type:-client}: $remote_Message with data: $remote_Data" >&2
					set -m # enable job control for disown
					emit_server_event "$opts_interface" "${peer_Type:-client}-message" "$remote_PublicKey" "$remote_Message" "$remote_Data" &>/dev/null & disown
					kill -SIGINT 0
					exit 0
				else
					echo "error: Remote[$remote_PublicKey]: Received unauthenticated message from ${peer_Type:-client}: $remote_Message. Remote address: $sock_addr" >&2
					sock_send "Error = 403 Forbidden"
					sock_send ""
					exit 43
				fi
				
			elif [ "$peer_Type" = "server" ] || [ "$remote_Type" = "server" ]
			then
				emit_server_event "$opts_interface" "server-connected" "$remote_PublicKey" >&2

			else
				emit_server_event "$opts_interface" "client-connected" "$remote_PublicKey" >&2
			fi
			
			
			if [ "$peer_Type" = "server" ]
			then
				if [ -z "$remote_PrefixMask" ]
				then
					remote_PrefixMask="$DEFAULT_VPN_PREFIX_MASK"
				fi
				
				# ensure correct configuration between servers in the same mesh
				if [ "$remote_PrefixMask" != "$local_PrefixMask" ]
				then
					echo "error: Remote[$remote_PublicKey]: PrefixMask configuration mismatch. Remote PrefixMask ($remote_PrefixMask) does not match local PrefixMask ($local_PrefixMask)." >&2
					sock_send "Error = 400 Bad Request"
					sock_send_lines "${interface_block[@]}"
					sock_send ""
					# event-name, peer-public-key, code, message
					emit_server_event "$opts_interface" "server-rejected" "$remote_PublicKey" "400" "PrefixMask configuration mismatch. Remote PrefixMask ($remote_PrefixMask) does not match local PrefixMask ($local_PrefixMask)." >&2
					exit 40
				fi
				
				# peer is an authorized server, connecting with us again (although it could be anyone, who has the server's public key!)
				# so if the peer already exists with this public key, and has new settings, then it MUST be connecting through the virtual network
				# instead of using the public endpoint
				lines=()
				
				# check if server is authenticated
				new_or_auth=$sock_authenticated
				# if not authenticated, check if server is registering for the first time (no AllowedIPs set yet)
				if ! $new_or_auth && [ -z "${peer_AllowedIPs[*]}" ]
				then
					new_or_auth=true
				fi
				
				# Address was received, and Address differs from AllowedIPs
				if $new_or_auth && [ "${#remote_Address[@]}" -gt 0 ] && [ "${peer_AllowedIPs[*]}" != "${remote_Address[*]}" ]
				then
					# combine server_Address to one line:
					read -r remote_AddressLine < <(join ', ' "${remote_Address[@]}")
					
					lines+=("AllowedIPs = $remote_AddressLine")
				fi
				
				# Endpoint was received, and Endpoint differs from Endpoint
				if $new_or_auth && $set_remote_Endpoint && [ "$remote_Endpoint" != "$peer_Endpoint" ]
				then
					# the connecting peer is responsible for adding its own ListenPort to the Endpoint address
					lines+=("Endpoint = $remote_Endpoint")
				fi
				
				# VirtualEndpoint was received, and VirtualEndpoint differs from VirtualEndpoint
				if $new_or_auth && $set_remote_VirtualEndpoint && [ "$remote_VirtualEndpoint" != "$peer_VirtualEndpoint" ]
				then
					# the connecting peer is responsible for adding its own ListenPort to the VirtualEndpoint address
					lines+=("VirtualEndpoint = $remote_VirtualEndpoint")
				fi
				
				# Ensure PersistentKeepalive is set to our current options (in case [Peer] will be created for the first time, or configuration was manually changed)
				if $new_or_auth && [ "$peer_PersistentKeepalive" != "$opts_persistent_keepalive_s" ]
				then
					lines+=("PersistentKeepalive = $opts_persistent_keepalive_s")
				fi
				
				# if any new lines need to be added
				if [ "${#lines[@]}" -gt 0 ]
				then
					# only update existing peer
					# if AllowedIPs, and AllowedIPs does not exist yet
					# if Endpoint, and Endpoint does not exist yet, OR, connected socket matches AllowedIPs

					# update configuration file
					if "$0" "$opts_interface" conf set-peer "$remote_PublicKey" < <(
						echo "[Peer]"
						echo "Type = server"
						for line in "${lines[@]}"
						do
							echo "$line"
						done
					) >&2
					then
						# apply new configuration to Wireguard interface
						"$0" "$opts_interface" update "$opts_interface" >&2
					else
						echo "error: Remote[$remote_PublicKey]: Failed to update configuration for Peer ($remote_PublicKey)." >&2
						sock_send "Error = 500 Internal Server Error"
						sock_send_lines "${interface_block[@]}"
						sock_send ""
						emit_server_event "$opts_interface" "server-rejected" "$remote_PublicKey" "500" "Failed to update configuration for Peer ($remote_PublicKey)." >&2
						exit 50
					fi
				fi
				
			elif [ "$remote_Type" = "server" ]
			then
				# this server wants to connect as a server, but it is not allowed as a server here
				# that is an error
				echo "warn: Remote[$remote_PublicKey]: Client wants to connect as a server, but is not authorized as a server. To authorize client as a server, run: $0 server allow $remote_PublicKey <<<Type=server" >&2
				sock_send "Error = 403 Forbidden (not authorized as server)"
				sock_send_lines "${interface_block[@]}"
				sock_send ""
				emit_server_event "$opts_interface" "server-rejected" "$remote_PublicKey" "403" "Client wants to connect as a server, but is not authorized as a server." >&2
				exit 43

			else # assume Type=client
				local_AddressMask=""
				local_AddressPrefix=""
				for address in "${local_Address[@]}"
				do
					case "$address" in
						*/128|*/128\$*|*/) ;;
						*/*)
							# trim cost
							address="${address%\$*}"
							
							local_AddressPrefix="${address%/*}"
							local_AddressMask="${address#*/}"
							
							# apply mask to the prefix to really turn it into a prefix
							read -r local_AddressPrefix < <(expand_ipv6 "$local_AddressPrefix")
							local_AddressPrefix="${local_AddressPrefix//:/}"
							hexdigit_count="$((local_AddressMask / 4))"
							local_AddressPrefix="${local_AddressPrefix:0:$hexdigit_count}"
							read -r local_AddressPrefix < <(hex_to_expanded_ipv6 "$local_AddressPrefix")
							read -r local_AddressPrefix < <(compress_ipv6 "$local_AddressPrefix")
							
							break # from for-loop, the first address with server-mask is chosen as prefix/mask
						;;
					esac
				done
				
				if [ -z "$local_AddressMask" ]
				then
					echo "error: Remote[$remote_PublicKey]: Local server is not currently a server (no Address mask has been specified, check configuration)." >&2
					sock_send "Error = 503 Service Unavailable (invalid server configuration)"
					sock_send_lines "${interface_block[@]}"
					sock_send ""
					emit_server_event "$opts_interface" "client-rejected" "$remote_PublicKey" "503" "Local server is not currently a server (no Address mask has been specified, check configuration)." >&2
					exit 53
				fi
				
				# peer is an authorized client (only the first AllowedIPs is considered)
				client_addr="${peer_AllowedIPs[0]}"
				
				# if client_addr starts with :, then automatically prepend the prefix&subnet
				case "$client_addr" in
					:*) client_addr="$local_AddressPrefix$client_addr"
				esac
				
				# validate ipv6 address (ip exit code is 1 if parse error)
				if is_ipv6 "$client_addr"
				then
					echo "info: Remote[$remote_PublicKey]: Found statically configured IPv6 address ($client_addr)." >&2
					
					# expand client_addr
					read -r client_addr < <(expand_ipv6 "$client_addr")
				else
					# mark as invalid address
					client_addr=""
				fi
				
				# if the client's Interface ID is provided, and if client_addr ends with a mask (e.g. /64), then overwrite the last digits with the client's Interface ID
				hexdigit_count="32"
				case "$client_addr" in
					*/*)
						client_addr_mask="${client_addr%%*/}"
						
						if is_num "$client_addr_mask"
						then
							hexdigit_count="$((client_addr_mask / 4))"
						fi
					;;
				esac
				
				# Retry using Client's Interface ID if provided
				if [ -n "$remote_InterfaceID" ] && {
						[ -z "$client_addr" ] || [ "$hexdigit_count" -lt 32 ]
					}
				then
					if is_ipv6 "$remote_InterfaceID"
					then
						read -r remote_InterfaceID_hex < <(expand_ipv6 "$remote_InterfaceID")
					else
						# else: could be a MAC-address, or any hexidecimal string
						read -r remote_InterfaceID_hex <<<"$remote_InterfaceID"
					fi
					
					# remove colons (if IPv6 it must already be expanded, so this is safe to do)
					# actually, remove any non-[a-f0-9] character
					read -r remote_InterfaceID_hex < <(strtolower "$(sed -r -e 's/[^0-9a-f]+//gi' <<<"$remote_InterfaceID_hex")")
					
					# preserve first $digit_count digits of the client_addr, and substitute the rest with client_interface_id, if a mask was provided for the client
					if [ "$hexdigit_count" -lt 32 ]
					then
						# if hexdigit_count < 32, then client_addr MUST have matched */*, meaning it's not empty, and expanded
						client_addr="${client_addr%/*}"
						# recombine hexdigits up to hexdigit_count, client_addr is already expanded
						client_addr="${client_addr//:/}"
						client_addr="${client_addr:0:$hexdigit_count}$remote_InterfaceID_hex"
					else
						# set client_addr to address prefix
						read -r client_addr < <(expand_ipv6 "$local_AddressPrefix::")
						
						# add client's Interface ID not before the end of AddressPrefix
						client_addr="${client_addr//:/}"
						client_addr_prefix="${client_addr:0:$((local_AddressMask / 4))}"
						offset="${#client_addr_prefix}"
						
						# for security, ensure that offset is not lower than 64-bit, a client can never remotely touch anything before 64-bit, that's only for the server to decide on
						clientsubnet_offset="$((64 / 4))"
						if [ "$offset" -lt "$clientsubnet_offset" ]
						then
							offset="$clientsubnet_offset"
						fi
						
						# if the remote Interface ID is not long enough to fill up the zeroes, move offset even more to the right (align to right)
						if [ "${#remote_InterfaceID_hex}" -lt "$((32 - offset))" ]
						then
							offset="$((32 - ${#remote_InterfaceID_hex}))"
						fi
						
						# add remote Interface ID at the given offset
						client_addr="${client_addr:0:$offset}$remote_InterfaceID_hex"
					fi
					
					# insert colons every 4 digits, client_addr is currently a hexstring without colons
					read -r client_addr < <(hex_to_expanded_ipv6 "$client_addr")
					
					# validate ipv6 address (ip exit code is 1 if parse error)
					if is_ipv6 "$client_addr"
					then
						echo "info: Remote[$remote_PublicKey]: Using IPv6 address ($client_addr) with Interface ID provided by client ($remote_InterfaceID)." >&2
					else
						echo "warning: Remote[$remote_PublicKey]: Interface ID ($remote_InterfaceID) provided by client is invalid ($client_addr)." >&2
						
						# clear the invalid address
						client_addr=""
					fi
				fi
				
				# fallback to automatic iterative IP-address assignment
				if [ -z "$client_addr" ]
				then
					# find unused ipv6 address
					# ::1 is typically reserved for the server's own address, start at 2
					count=2
					client_addr="$local_AddressPrefix::$count"
					client_addr="${client_addr//::::/::}"
					
					# the mask might limit clients to an even lower limit than 4 hex-digits
					max_clients="$((2**((128 - $local_AddressMask)/2)))"
					if [ "$max_clients" -gt 65536 ]
					then
						# hard-limit to 65536 clients, otherwise the code to generate client ID's needs to be updated
						max_clients=65536
					fi
					
					# we could also use "$0" "$opts_interface" conf has-address <Address>, to check for uniqueness
					while [ "$count" -lt "$max_clients" ] && "$0" "$opts_interface" conf has-address "$client_addr"
					do
						# add 1 to the last hex group (this method limits the number of clients to a maximum of 65534 clients)
						client_addr="${client_addr%:*}:$(printf '%x' "$((16#${client_addr##*:} + 1))")"
						
						count=$((count + 1))
					done
					
					if [ "$count" -eq "$max_clients" ]
					then
						echo "error: Remote[$remote_PublicKey]: Address space exhausted, too many clients ($count)." >&2
						sock_send "Error = 507 Insufficient Storage (address space exhausted, too many clients)"
						sock_send_lines "${interface_block[@]}"
						sock_send ""
						emit_server_event "$opts_interface" "client-rejected" "$remote_PublicKey" "507" "Address space exhausted, too many clients ($count)." >&2
						exit 57
					fi
				fi
				
				# compress client_addr
				read -r client_addr < <(compress_ipv6 "$client_addr")
				
				# check if our client_addr is new/changed:
				if [ "$client_addr" != "${peer_AllowedIPs[0]}" ]
				then
					# check if address is unique:
					if "$0" "$opts_interface" conf has-address "$client_addr"
					then
						echo "error: Remote[$remote_PublicKey]: Forbidden address ($client_addr), it already exists in the configuration as an Address or AllowedIPs ($conf_file)." >&2
						sock_send "Error = 409 Conflict (forbidden address: $client_addr, not unique)"
						sock_send_lines "${interface_block[@]}"
						sock_send ""
						emit_server_event "$opts_interface" "client-rejected" "$remote_PublicKey" "409" "Forbidden address ($client_addr), it already exists in the configuration as an Address or AllowedIPs ($conf_file)." >&2
						exit 49
					fi
					
					case "$client_addr" in
						*::|*:0)
							echo "error: Remote[$remote_PublicKey]: Forbidden address ($client_addr), it ends with :: or :0." >&2
							sock_send "Error = 409 Conflict (forbidden address: $client_addr, ends with :: or :0)"
							sock_send_lines "${interface_block[@]}"
							sock_send ""
							emit_server_event "$opts_interface" "client-rejected" "$remote_PublicKey" "409" "Forbidden address ($client_addr), it ends with :: or :0." >&2
							exit 49
						;;
						"$local_AddressPrefix"*) ;; # this is correct, client_addr should be in the subnet of this server
						*)
							echo "error: Remote[$remote_PublicKey]: Forbidden address ($client_addr), it does not start with the server prefix ($local_AddressPrefix)." >&2
							sock_send "Error = 409 Conflict (forbidden address: $client_addr, bad prefix)"
							sock_send_lines "${interface_block[@]}"
							sock_send ""
							emit_server_event "$opts_interface" "client-rejected" "$remote_PublicKey" "409" "Forbidden address ($client_addr), it does not start with the server prefix ($local_AddressPrefix)." >&2
							exit 49
						;;
					esac
					
					# check if a peer_VirtualHostname already exists
					auto_hostname_line=""
					if [ -n "$remote_VirtualHostname" ] && [ -z "$peer_VirtualHostname" ] && [ "$remote_VirtualHostname" != "localhost" ]
					then
						# now check if remote_VirtualHostname doesn't already exist (it must be unique, and unused, also as a public DNS)
						if ! getent hosts "$remote_VirtualHostname" >/dev/null 2>/dev/null && ! getent ahosts "$remote_VirtualHostname" >/dev/null 2>/dev/null
						then
							auto_hostname_line="VirtualHostname = $remote_VirtualHostname"
						fi
					fi

					# check if client_addr is unique (must be done by set-peer, for atomic locking purposes)
					if "$0" "$opts_interface" conf set-peer "$remote_PublicKey" >&2 <<EOF
Type = client
AllowedIPs = $client_addr
$auto_hostname_line

EOF
					then
						echo "info: Remote[$remote_PublicKey]: Configuration updated. Peer (PublicKey = $remote_PublicKey) added with virtual IP-address: $client_addr" >&2
						
						# refresh Wireguard configuration
						"$0" "$opts_interface" update "$opts_interface" >&2
						
						emit_server_event "$opts_interface" "client-updated" "$remote_PublicKey" "$client_addr" >&2
					else
						echo "error: Remote[$remote_PublicKey]: Failed to update configuration for Peer ($remote_PublicKey)." >&2
						sock_send "Error = 500 Internal Server Error"
						sock_send_lines "${interface_block[@]}"
						sock_send ""
						emit_server_event "$opts_interface" "client-rejected" "$remote_PublicKey" "500" "Failed to update configuration for Peer ($remote_PublicKey)." >&2
						exit 50
					fi
				fi
			fi
			
			# only if client is authorized (and after possible [Peer]-server section has been updated), we show properties about the internals of this virtual network:
			sock_send_lines "${interface_block[@]}"
			
			relay_addresses=()
			# here we also want to print every Peer we relay for as our own Address, but with increased cost
			# this is for both the client and server so it may discover other servers in the mesh
			max_cost="1024"
			while read -r pubkey address
			do
				[ -n "$address" ] || continue
				
				case "$address" in
					*\$*)
						relay_ip="${address%\$*}"
						relay_cost="${address#*\$}"
						
						if [ -z "$relay_cost" ]
						then
							# default relay cost, if no number is indicated at the end, is zero
							relay_cost="0"
						fi
						
						if [ "$relay_cost" -gt "$max_cost" ]
						then
							max_cost="$relay_cost"
						fi
						
						relay_addresses+=("${relay_ip}\$$((relay_cost + 1))")
					;;
					*)
						relay_addresses+=("${address}\$1")
					;;
				esac
				
			done < <("$0" "$opts_interface" conf list-servers AllowedIPs)
			
			# print the local address
			prefix_addresses=()
			for address in "${local_Address[@]}"
			do
				sock_send "Address = $address"
				
				# expand address
				read -r expanded_addr < <(expand_ipv6 "$address" | tr -d ':')
				# back to a correct ipv6 address
				read -r addr < <(hex_to_expanded_ipv6 "${expanded_addr:0:$(($local_PrefixMask/4))}")
				# create catchall address based on prefix
				prefix_catchall_addr="${addr}/$local_PrefixMask"
				
				# check if already printed
				if ! array_contains "$prefix_catchall_addr" "${prefix_addresses[@]}"
				then
					prefix_addresses+=("$prefix_catchall_addr")
				fi
			done
			for address in "${relay_addresses[@]}"
			do
				sock_send "Address = $address"
			done
			for address in "${prefix_addresses[@]}"
			do
				read -r compressed_addr < <(compress_ipv6 "$address")
				sock_send "Address = $compressed_addr\$$max_cost"
			done
			
			# client exists, show all configuration entries of this client:
			# this is mostly useful for the client so that it may read AllowedIPs and set it as its [Interface]'s Address
			# note on security: anyone who knows a client's identifier can discover their IP-address, public key, and potentially other properties
			
			while read -r line
			do
				sock_send "$line"
				
			done < <("$0" "$opts_interface" conf get-peer "$remote_PublicKey")
			
			sock_send ""
			
			if [ "$peer_Type" = "server" ]
			then
				emit_server_event "$opts_interface" "server-accepted" "$remote_PublicKey" >&2
			else
				emit_server_event "$opts_interface" "client-accepted" "$remote_PublicKey" >&2
			fi
		;;
		*)
			echo "error: Invalid server command ($opts_command)." >&2
			exit 1
		;;
	esac
}

context_find()
{
	# grab address from argument
	opts_vpn_address="$1"
	
	# extract subnet mask, default to default prefix mask
	find_mask="$DEFAULT_VPN_PREFIX_MASK"
	case "$opts_vpn_address" in
		*/*)
			find_mask="${opts_vpn_address#*/}"
			opts_vpn_address="${opts_vpn_address%/*}"
		;;
	esac
	
	# prefix address with :: before expanding, if needed
	if ! is_ipv6 "$opts_vpn_address"
	then
		case "$opts_vpn_address" in
			::*) ;;
			:*)
				opts_vpn_address=":$opts_vpn_address"
			;;
			*)
				opts_vpn_address="::$opts_vpn_address"
			;;
		esac
	fi
	
	# expand address
	read -r opts_vpn_address < <(expand_ipv6 "$opts_vpn_address")
	
	# remove colons
	opts_vpn_address="${opts_vpn_address//:/}"
	
	# remove digits from the front according to the find_mask
	opts_vpn_address="${opts_vpn_address:$((find_mask / 4))}"
	
	addresses=()
	
	# find the subnet at which
	while read -r pubkey address _
	do
		# remove cost
		address="${address%\$*}"
		
		# extract route mask
		route_mask="128"
		case "$address" in
			*/*)
				route_mask="${address#*/}"
				address="${address%/*}"
			;;
		esac
		
		# expand route address
		read -r address < <(expand_ipv6 "$address")
		
		# remove colons
		address="${address//:/}"
		
		# if route mask is larger than find_mask, only match if the ending part matches exactly
		if [ "$route_mask" -gt "$find_mask" ]
		then
			# check if the address is equal to the opts_vpn_address
			if [ "${address:$((find_mask / 4))}" = "$opts_vpn_address" ]
			then
				read -r address < <(hex_to_expanded_ipv6 "${address:0:$((find_mask / 4))}$opts_vpn_address")
				
				#echo "Found local matching address: $address"
				
				compress_ipv6 "$address"
				exit 0
			fi
			# else: no match
			
		else
			address="${address:0:$((find_mask / 4))}$opts_vpn_address"
			
			# put colons back in
			read -r address < <(hex_to_expanded_ipv6 "$address")
			
			#echo "Going to ping: $address"
			
			addresses+=("$address")
		fi
		
	done < <("$0" "$opts_interface" conf list-servers AllowedIPs)
	
	# only print the first line
	head -n 1 < <(
		pids=()
		for address in "${addresses[@]}"
		do
			# scan this address in parallel for a result
			(
				if ping -6 -n -c 1 -w 2 -W 4 "$address" >/dev/null 2>/dev/null
				then
					compress_ipv6 "$address"
				else
					exit 1
				fi
			) &
			pids+=($!)
		done
		
		# wait for the first job to finish
		while [ -n "$(jobs -pr)" ]
		do
			wait -n && break
		done
		
		# kill remaining pids
		while [ -n "$(jobs -pr)" ]
		do
			kill %%
		done
	)
}

opts_context=""
opts_verbosity="0"
opts_vpn_address=""
opts_bind_host="$DEFAULT_BIND_HOST"
opts_alive_count_max="3"
opts_persistent_keepalive_s="$DEFAULT_PERSISTENT_KEEPALIVE_S"
opts_mac_address=""
opts_prefix_mask="$DEFAULT_VPN_PREFIX_MASK"

while [ "$#" -gt 0 ]
do
	case "$1" in
		--)
			shift
			break
		;;
		-a|--address)
			# if starts with colon, prefix with default fd77 prefix
			opts_vpn_address="$2"
			case "$opts_vpn_address" in
				:*) opts_vpn_address="$DEFAULT_VPN_PREFIX$opts_vpn_address"
			esac
			
			# if does not have a mask, assume based on colon count given where trailing ::* is removed
			case "$opts_vpn_address" in
				*/*) ;;
				*)
					# if partial prefix address, then add :: at the end
					if ! is_ipv6 "$opts_vpn_address"
					then
						opts_vpn_address="${opts_vpn_address%%:}"
						opts_vpn_address="$opts_vpn_address::"
					fi
					
					# count hex digits to automatically determine the subnet mask, using :: as a separator between the server's Interface ID and the subnet mask
					read -r hexdigits < <(expand_ipv6 "${opts_vpn_address%%::*}")
					read -r hexdigits < <(sed -r -e 's/://g' -e 's/0+$//g' <<<"$hexdigits")
					opts_vpn_address="$opts_vpn_address/$((4 * ${#hexdigits}))"
				;;
			esac
			
			# if ends with : or ::, then set to end with ::1 (::0 is considered invalid, bad practice to use this, reserved for special meaning)
			case "$opts_vpn_address" in
				*:/*) opts_vpn_address="${opts_vpn_address/:\//:1\/}"
			esac
			
			# check if argument is a valid IPv6-address
			if ! is_ipv6 "$opts_vpn_address"
			then
				echo "error: Invalid usage. The address argument (-a) expects a valid IPv6-address (deduced $opts_vpn_address from $2)."
				exit 1
			fi
			
			[ "$opts_verbosity" -lt 1 ] || echo "debug: Parsed address argument: $opts_vpn_address"
			
			shift
		;;
		--alive-count-max)
			opts_alive_count_max="$2"
			shift
		;;
		-k|--keepalive)
			opts_persistent_keepalive_s="$2"
			shift
		;;
		-b|--bind)
			opts_bind_host="$2"
			shift
		;;
		-m|--mac-address)
			case "$2" in
				*[^0-9a-f:-]*|"") ;; # if empty, or contains illegal MAC-address character (also allow dashes for hexadecimal uuid's)
				*)
					opts_mac_address="$2"
					shift
				;;
			esac
		;;
		-p|--prefix-mask)
			opts_prefix_mask="${2#*/}"
			shift
		;;
		-v|-vv)
			opts_verbosity=$((opts_verbosity + ${#1} - 1))
		;;
		-h|--help)
			print_usage "$2"
			exit
		;;
		-*)
			echo "error: Invalid option ($1)."
			print_usage "$opts_context"
			exit 1
		;;
		*)
			if [ -z "$opts_interface" ]
			then
				opts_interface="$1"
				
				if [ "$opts_interface" = "auto" ]
				then
					# interpret special value for interface 'auto' will set interface to wgX, where X is the first number (starting from 0) that has a configuration file, or has no existing link device
					for ((i=0;i<255;++i))
					do
						if [ -e "/etc/wireguard/wg$i.conf" ] || ! ip link show dev "wg$i" >/dev/null 2>/dev/null
						then
							opts_interface="wg$i"
							break
						fi
					done
					
					# when 255 is reached, give up, and use 'auto' as literal string for the link device
				fi
				
			elif [ -z "$opts_context" ]
			then
				opts_context="$1"
			else
				break
			fi
		;;
	esac
	
	shift || break
done

if [ -z "$opts_interface" ]
then
	echo "error: Invalid usage. No interface given."
fi

case "$opts_context" in
	help)
		print_usage
	;;
	conf)
		context_conf "$@"
	;;
	protocol)
		context_protocol "$@"
	;;
	client)
		context_client "$@"
	;;
	server)
		context_server "$@"
	;;
	find)
		context_find "$@"
	;;
	up|update|down)
		context_wg "$opts_context" "$@"
	;;
	*)
		wg "$opts_context" "$@"
	;;
esac
