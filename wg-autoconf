#!/usr/bin/env bash

# note: Origin of default prefix: wireguard = WireGuard = ['w', 'g'] = [119, 103] = [0x77, 0x67] = 7767::
# note: The server exposes a TCP-socket at the same port as as wireguard (which is listening to UDP), due to the different protocol, these ports are not in conflict
# note: The wg-autoconf non-standard configuration is stored in /etc/wireguard/<interface>.autoconf, the derived configuration for Wireguard is in /etc/wireguard/<interface>.conf

# TODO: add INPUT/OUTPUT chain for UDP/TCP ports, so that it can be cleaned up in a simple way, even if the ListenPort has changed meanwhile
# TODO: the "AllowedIP has nonzero host part" warning can be prevented by filtering the config accordingly (in: wg-autoconf conf strip)
# TODO: add support for MASQUERADE
# TODO: update usage manual, and shorten double-ish code (put in functions)
# TODO: make wg-monitor that checks tunnel periodically (not as a keepalive), and automatically runs connect again (which also updates DNS to fetch new IP-address for Endpoints)

# default port as per Wireguard docs
WIREGUARD_PORT="51820"

# metrics to use for routes that are direct vs relayed routes
# relay metric must be higher than server metric
LOCAL_METRIC="300"
RELAY_METRIC_FACTOR="100"

# default interface to use, this is arbitrary, but wgX is common
DEFAULT_INTERFACE="wg0"

# higher MTU is better for performance, MTU is min 1280, and typically max 1500, if MTU is too high, all or some packets may drop, usually 1400 is a safe value
DEFAULT_MTU="1400"

# Sensible default values:
DEFAULT_VPN_PREFIX="7767"
DEFAULT_VPN_ADDRESS="$DEFAULT_VPN_PREFIX:1::1/32"

DEFAULT_SUBNET_MASK="48"
DEFAULT_BIND_HOST="::"
DEFAULT_PERSISTENT_KEEPALIVE_S="25"

opts_interface="$DEFAULT_INTERFACE"
opts_vpn_address=""
opts_bind_host="$DEFAULT_BIND_HOST"
opts_persistent_keepalive_s="$DEFAULT_PERSISTENT_KEEPALIVE_S"
opts_verbosity="0"
opts_mac_address=""
opts_subnet_mask="$DEFAULT_SUBNET_MASK"

print_usage()
{
	context="$1"
	case "$context" in
		server|client|conf|wg) ;;
		*) context=""
	esac
	
	echo "wg-autoconf: Automated Wireguard configuration cli-tool."
	echo ""
	echo "DEPENDENCIES"
	echo " -> wg"
	echo " -> socat"
	echo " -> ip6tables"
	echo " -> flock, ip, grep, sed, cat (busybox)"
	echo " -> any modern Linux shell (bash)"
	echo ""
	echo ""
	echo "USAGE"
	echo "  $0 [OPTIONS] ${context:-<server|client|conf|wg>} <COMMAND>"
	echo ""
	echo ""
	echo "OPTIONS"
	echo "  -i <interface>       Set name of the wireguard-interface."
	echo "                       Defaults to: $DEFAULT_INTERFACE"
	echo "  -v                   Increase verbosity."
	echo "  -h, --help <context> Show this help. Context can be any of server, client,"
	echo "                       or conf."
	echo "                       Defaults to: Show help for all contexts."
	echo ""
	echo ""
	if [ -z "$context" ] || [ "$context" = "wg" ]
	then
		echo "WG COMMANDS"
		echo ""
		echo "  update"
		echo ""
		echo "      Synchronize configuration file with the Wireguard interface, and ensure"
		echo "      all ip6tables rules and ip routes are setup correctly. Does not bring"
		echo "      the Wireguard interface up if it is down."
		echo ""
		echo "  up"
		echo ""
		echo "      Same as update, but also ensures the Wireguard interface is brought up."
		echo ""
		echo "  down"
		echo ""
		echo "      Bring the Wireguard interface down. All ip6tables and ip routes rules"
		echo "      are also cleaned up."
		echo ""
		echo ""
	fi
	if [ -z "$context" ] || [ "$context" = "server" ]
	then
		echo "SERVER COMMANDS"
		echo ""
		echo "  connect <host> [port]"
		echo ""
		echo "      Connect to the given server running wg-autoconf listen."
		echo "      To be run by a server. Will register itself (as a server) at the remote"
		echo "      server. If the local public key is authorized by the remote server, the"
		echo "      remote server will append a Peer-section with this local server as its"
		echo "      endpoint."
		echo "      Port defaults to 51820."
		echo ""
		echo "  listen [port]"
		echo ""
		echo "      Listen at the given TCP-port."
		echo "      Any remote clients and servers can connect, and if authorized, be added"
		echo "      to the subnet that this server provides."
		echo "      Port defaults to 51820."
		echo ""
		echo "  allow <public-key> [Type=<server|client>]"
		echo ""
		echo "      Allow Peer identified by the given Public Key to connect."
		echo "      Ensures a Peer-section in the configuration file."
		echo "      If Type is set to server, the Peer will be able to register its own"
		echo "      Endpoint and AllowedIPs entries upon connect."
		echo ""
		echo "  deny <public-key>"
		echo ""
		echo "      Deny Peer identified by the given Public Key from connecting."
		echo "      Removes a Peer-section from the configuration file."
		echo ""
		echo ""
		echo "SERVER CONNECT OPTIONS"
		echo ""
		echo "  -k <seconds>      Set persistent keepalive seconds."
		echo "                    Defaults to: $DEFAULT_PERSISTENT_KEEPALIVE_S"
		echo ""
		echo ""
		echo "SERVER LISTEN OPTIONS"
		echo ""
		echo "  -a <ipv6-address> Set address of the server in the virtual IPv6 network"
		echo "                    Defaults to: $DEFAULT_VPN_ADDRESS"
		echo "  -b <bind-host>    Set host to bind to."
		echo "                    Defaults to: $DEFAULT_BIND_HOST"
		echo "                    Use 0.0.0.0 to bind to every IPv4 interface."
		echo "                    Use :: to bind to every IPv6 interface."
		echo "                    In order to listen at both IPv4 and IPv6 interfaces, two"
		echo "                    separate instances must be run."
		echo "  -s <mask>         Specify a bitmask for the subnet division. Any client that"
		echo "                    is connected to the virtual network can access any other"
		echo "                    client, but only if it is in the same subnet."
		echo "                    Defaults to: $DEFAULT_SUBNET_MASK"
		echo ""
		echo ""
	fi
	if [ -z "$context" ] || [ "$context" = "client" ]
	then
		echo "CLIENT COMMANDS"
		echo ""
		echo "  connect <host> [port]"
		echo ""
		echo "      Connect to the given server running wg-autoconf listen."
		echo "      To be run by a client, any existing configuration for this interface"
		echo "      will be completely overwritten. Do NOT run as server, since all"
		echo "      existing clients will be disconnected, and manual configuration changes"
		echo "      will be deleted."
		echo "      Port defaults to 51820."
		echo ""
		echo ""
		echo "CLIENT CONNECT OPTIONS"
		echo ""
		echo "  -m [MAC-address]  Set the Interface ID part of the IPv6 address. If the"
		echo "                    MAC-address is not defined, then it will default to the"
		echo "                    first available network device, which is then cached for"
		echo "                    subsequent connects in: /etc/wireguard/<interface>.id"
		echo "                    The server is not guaranteed to incorporate the"
		echo "                    Interface ID into the client's allowed IP address (i.e."
		echo "                    in case the ID is not unique)."
		echo "  -k <seconds>      Set persistent keepalive seconds."
		echo "                    Defaults to: $DEFAULT_PERSISTENT_KEEPALIVE_S"
		echo ""
		echo ""
	fi
	if [ -z "$context" ] || [ "$context" = "conf" ]
	then
		echo "CONF COMMANDS"
		echo ""
		echo "  show"
		echo ""
		echo "      Print the contents of the configuration file."
		echo ""
		echo "  get-interface [entry]"
		echo ""
		echo "      Print the Interface-section of the configuration file."
		echo "      If an entry is specified, only the value of that entry is printed."
		echo "      If an entry has multiple values separated by a comma, these values"
		echo "      are printed on separate lines."
		echo ""
		echo "  get-peer <public-key> [entry]"
		echo ""
		echo "      Print the Peer-section of the configuration file, that contains a"
		echo "      PublicKey entry with the given public-key value."
		echo "      If an entry is specified, only the value of that entry is printed."
		echo "      If an entry has multiple values separated by a comma, these values"
		echo "      are printed on separate lines."
		echo ""
		echo "  strip"
		echo ""
		echo "  list-peers"
		echo ""
		echo "  set-peer"
		echo ""
		echo ""
	fi
	if [ -z "$context" ]
	then
		echo "AUTOCONF CONFIGURATION FILE"
		echo ""
		echo "wg-autoconf uses non-standard properties, which are by prefixed by a single"
		echo "comment character (#). These actually have effect, and are not considered"
		echo "comments for wg-autoconf, but are comments with regard to Wireguard. This"
		echo "allows for complete compatibility with Wireguard."
		echo ""
		echo ""
		echo "AUTOCONF PROTOCOL"
		echo ""
		echo "wg-autoconf listens on the same port as WireGuard. Since wg-autoconf uses"
		echo "TCP, and WireGuard uses UDP, there is no conflict."
		echo ""
		echo "Within the virtual network, only IPv6-addresses are supported due to its"
		echo "additional flexibility. For the real non-virtual network, both IPv4 and IPv6"
		echo "are supported."
		echo ""
		echo ""
		echo "IPV6 FORWARDING AND IP6TABLES"
		echo ""
		echo "Note that when using listen, IPv6 forwarding is enabled (and accept_ra is set"
		echo "to 2). This is why, for security, the default policy of the FORWARD chain will"
		echo "be set to DROP. That is, no IPv6 forwarding is allowed unless explicitly"
		echo "accepted by a rule in the FORWARD chain of ip6tables."
		echo ""
		echo "Any ip6tables rules that are added by wg-autoconf, will be in a separate chain"
		echo "and will be automatically cleaned up when running the down command."
		echo ""
		echo ""
		echo "RECOMMENDED IPV6 ALLOCATION"
		echo ""
		echo "  <prefix> : <server> : <subnet> : <unused> : <interface-identifier>"
		echo ""
		echo "Where:"
		echo " -> prefix is a unique identifier for this virtual private network."
		echo " -> server is a unique identifier for each individual server (i.e. site)."
		echo " -> subnet isolates clients from each other that are in different subnets."
		echo " -> unused is a further custom distinction of client groups, may be left zero."
		echo " -> interface-identifier is a 64-bit identifier reserved to uniquely identify"
		echo "    clients across multiple subnets and groups. By default this is the"
		echo "    MAC-address of the client."
		echo ""
		echo ""
		echo "TROUBLESHOOTING"
		echo ""
		echo " 1. Check if interface is up and has the intended virtual IPv6-address"
		echo " 2. Check if IPv6-forwarding is enabled, using:"
		echo ""
		echo "      cat /proc/sys/net/ipv6/conf/<wg0|all>/forwarding"
		echo ""
		echo " 3. Check if the virtual IPv6-address is routed correctly, using:"
		echo ""
		echo "      ip -6 route [dev wg0]"
		echo ""
		echo " 4. Check if the route is blocked by netfilter with ip6tables:"
		echo ""
		echo "      ip6tables -L"
		echo ""
		echo " 5. Check from the client's perspective if the Endpoint IP-address in"
		echo "    the [Peer] section that belongs to the server is correct."
		echo " 6. Check if the port in the Endpoint from step 5 is correct."
		echo " 7. Check if the port from step 6 matches the ListenPort on the server:"
		echo "    wg show <wg0> listen-port"
		echo " 8. Check if the PublicKey entry of the [Peer] section matches the"
		echo "    PublicKey generated from the PrivateKey of the [Interface] section"
		echo "    of the other peer. Check both ends. If one end is misconfigured,"
		echo "    then the whole connection fails."
		echo ""
		echo "Wireguard uses the UDP-protocol, the wg-autoconf utility uses TCP-protocol."
		echo "Debug UDP traffic using:"
		echo ""
		echo "    tcpdump -n udp"
		echo ""
		echo "If ping to a virtual address fails with:"
		echo ""
		echo "    Destination unreachable: Address unreachable"
		echo ""
		echo "then the traffic is correctly locally routed through the Wireguard link"
		echo "device, but Wireguard responds that the virtual target IPv6-address is"
		echo "unreachable. Check the AllowedIPs of the relevant [Peer] section."
		echo ""
		echo "Wireguard will give a warning:"
		echo ""
		echo "    warning: AllowedIP has nonzero host part"
		echo ""
		echo "which can be safely ignored. It indicates a subnet mask catches more than"
		echo "one specific IPv6-address, and thus for clarity it should end with zeroes"
		echo "(::). But wg-autoconf specifies the address anyway, to store the IP-address"
		echo "of the server itself."
		echo ""
		echo "If a server is added to the mesh, all previously connected peers (clients"
		echo "and servers) must reconnect using wg-autoconf. So that the new IP-addresses"
		echo "are propagated. If the mesh is dynamic, it is highly recommended to use"
		echo "wg-monitor which automatically propagates updates through the mesh network"
		echo "and furthermore keeps connections alive (to achieve redundancy)."
		echo ""
		echo ""
		
	fi
}
expand_ipv6()
{
	__expand_ipv6_ip="${1%%/*}"
	__expand_ipv6_mask=""

	# extract and filter mask at end of address
	case "$1" in
		*/*)
			__expand_ipv6_mask="${1#*/}"
			__expand_ipv6_mask="/${__expand_ipv6_mask%%[^0-9/]*}"
	esac

	case "$__expand_ipv6_ip" in
		:*) __expand_ipv6_ip="0$__expand_ipv6_ip"
	esac

	case "$__expand_ipv6_ip" in
		*::*)
			__expand_ipv6_colons="$(tr -c -d ':' <<<"$__expand_ipv6_ip")"
			__expand_ipv6_expanded="$(echo ":::::::::" | sed -e "s/$__expand_ipv6_colons//" -e 's/:/:0/g')"
			__expand_ipv6_ip="$(echo "$__expand_ipv6_ip" | sed "s/::/$__expand_ipv6_expanded/")"
		;;
	esac

	__expand_ipv6_blocks="$(echo "$__expand_ipv6_ip" | grep -o '[0-9a-f]\+' | while read -r __expand_ipv6_hex; do [ -n "$__expand_ipv6_hex" ] && printf " %d" "$((0x$__expand_ipv6_hex))"; done)"
	printf "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x" $__expand_ipv6_blocks
	printf "%s\n" "$__expand_ipv6_mask"
}
compress_ipv6()
{
	__compress_ipv6_ip="$1"
	
	__compress_ipv6_ip="$(echo "$__compress_ipv6_ip" | sed -e 's/::/:0:/g' | grep -o "[0-9a-f]\+" | while read -r __compress_ipv6_hex; do [ -n "$__compress_ipv6_hex" ] && printf ":%x" "$((0x$__compress_ipv6_hex))"; done)"
	
	for __compress_ipv6_chain in :0:0:0:0:0:0:0:0 :0:0:0:0:0:0:0 :0:0:0:0:0:0 :0:0:0:0:0 :0:0:0:0 :0:0:0 :0:0 :0
	do
		case "$__compress_ipv6_ip" in
			*$__compress_ipv6_chain*)
				__compress_ipv6_ip="$(echo "$__compress_ipv6_ip" | sed -e "s/$__compress_ipv6_chain/::/" -e 's/:::/::/')"
				break
		esac
	done

	case "$__compress_ipv6_ip" in
		::*) ;;
		:*) __compress_ipv6_ip="${__compress_ipv6_ip#:}"
	esac

	echo "$__compress_ipv6_ip"
}
is_ipv6()
{
	ip -6 route get "$1" >/dev/null 2>/dev/null || [ $? -ne 1 ]
}
is_mac_addr()
{
	case "$1" in
		[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]:[0-9a-f][0-9a-f]) return 0
	esac
	return 1
}
is_num()
{
	case "$1" in
		''|*[!0-9]*)
			# matched empty string, or contains non-numeric char
		;;
		*)
			return 0
		;;
	esac
	return 1
}
cmd()
{
	echo "> $*"
	"$@"
}
ensure_ip6tables()
{
	if ! ip6tables-save | grep -qFx -- "$*"
	then
		cmd ip6tables "$@"
	fi
}
ensure_ip()
{
	echo "> ip $*"
	__ensure_ip_code="0"
	__ensure_ip_err="$(ip "$@" 2>&1)" || __ensure_ip_code="$?"
	
	if [ "$__ensure_ip_code" == "0" ]
	then
		return 0
		
	elif [ "$__ensure_ip_code" == "2" ]
	then
	       	case "$__ensure_ip_err" in
			*File\ exists*)
				return 0
			;;
			*)
				echo "error: ($__ensure_ip_code) Failed to execute command ($*)."
				return 1
		esac
	else
		echo "error: ($__ensure_ip_code) Failed to execute command ($*)."
		return 1
	fi
}
ensure_ip6route()
{
	ensure_ip -6 route append "$@"
}
ensure_ip6address()
{
	ensure_ip -6 address add "$@"
}
ensure_ipv6_brackets()
{
	case "$1" in
		\[*:*:*) ;;
		*:*:*)
			echo "[$1]"
			return 0
	esac
	echo "$1"
}
strtolower()
{
	tr '[:upper:]' '[:lower:]' <<<"$1"
}
strtoupper()
{
	tr '[:lower:]' '[:upper:]' <<<"$1"
}
join()
{
	__join_delim="$1"
	shift
	if [ "$#" -gt 0 ]
	then
		echo -n "$1"
		shift
		for __join_elem in "$@"
		do
			echo -n "$__join_delim$__join_elem"
		done
	fi
	echo
}
# usage note: only works with a delimiter of 1 character, automatically trims every entry, and values should not contain ' or \
# usage: split ',' "$csv" array
# usage: array=($(split ',' "$csv"))
split()
{
	__split_delim="$1"
	__split_input="$2"
	__split_var="$3"
	
	while read -d "$__split_delim" -r __split_entry
	do
		# trim entry
		read -r __split_entry <<<"$__split_entry"
		
		# skip empty entries
		[ -n "$__split_entry" ] || continue
		
		if [ -n "$__split_var" ]
		then
			# assign entry to array (if given)
			eval "$__split_var+=('$__split_entry')"
		else
			# print every entry on a new line
			echo "$__split_entry"
		fi
		
	done <<<"$input$delim"
}
sock_send()
{
	printf "%s\n" ">> $*" >&2
	printf "%s\n" "$*"
}
sock_receive()
{
	printf "%s\n" "<< $*" >&2
}


opts_context=""
opts_command=""

while true
do
	if [ "$1" = "--" ]
	then
		shift
		break

	elif [ "$1" = "server" ]
	then
		opts_context="server"
	
	elif [ "$1" = "client" ]
	then
		opts_context="client"
	
	elif [ "$1" = "connect" ]
	then
		if [ -z "$opts_context" ]
		then
			# automatically deciding on client or server as context is dangerous here
			echo "error: Invalid usage. Specify a context before the $1-command."
			echo "Usage: $0 <client|server> connect <host> [port]"
			exit 1
		fi
		opts_command="connect"
	
	elif [ "$1" = "listen" ]
	then
		if [ -z "$opts_context" ]
		then
			echo "error: Invalid usage. Specify a context before the $1-command."
			echo "Usage: $0 server listen [port]"
			exit 1
		fi
		opts_command="listen"
	
	elif [ "$1" = "-i" ]
	then
		opts_interface="$2"
		shift
	
	elif [ "$1" = "-a" ]
	then
		# if starts with colon, prefix with default 7767 prefix
		opts_vpn_address="$2"
		case "$opts_vpn_address" in
			:*) opts_vpn_address="$DEFAULT_VPN_PREFIX$opts_vpn_address"
		esac
		
		# if does not have a mask, assume based on colon count given where trailing ::* is removed
		case "$opts_vpn_address" in
			*/*) ;;
			*)
				# if partial prefix address, then add :: at the end
				if ! is_ipv6 "$opts_vpn_address"
				then
					opts_vpn_address="${opts_vpn_address%%:}"
					opts_vpn_address="$opts_vpn_address::"
				fi
				
				# count hex digits to automatically determine the subnet mask, using :: as a separator between the server's Interface ID and the subnet mask
				read -r hexdigits < <(expand_ipv6 "${opts_vpn_address%%::*}")
				read -r hexdigits < <(sed -r -e 's/://g' -e 's/0+$//g' <<<"$hexdigits")
				opts_vpn_address="$opts_vpn_address/$((4 * ${#hexdigits}))"
			;;
		esac
		
		# if ends with : or ::, then set to end with ::1 (::0 is considered invalid, bad practice to use this, reserved for special meaning)
		case "$opts_vpn_address" in
			*:/*) opts_vpn_address="${opts_vpn_address/:\//:1\/}"
		esac
		
		# check if argument is a valid IPv6-address
		if ! is_ipv6 "$opts_vpn_address"
		then
			echo "error: Invalid usage. The address argument (-a) expects a valid IPv6-address (deduced $opts_vpn_address from $2)."
			exit 1
		fi
		
		[ "$opts_verbosity" -lt 1 ] || echo "debug: Parsed address argument: $opts_vpn_address"
		
		shift
	
	elif [ "$1" = "-k" ]
	then
		opts_persistent_keepalive_s="$2"
		shift
	
	elif [ "$1" = "-b" ]
	then
		opts_bind_host="$2"
		shift
	
	elif [ "$1" = "-m" ]
	then
		opts_mac_address="$2"
		case "$2" in
			*[^0-9a-f:-]*|"")
				# if empty, or contains illegal MAC-address character, set to auto (also allow dashes for hexadecimal uuid's)
				opts_mac_address="auto"
			;;
			*)
				# consume argument
				shift
			;;
		esac
	
	elif [ "$1" = "-s" ]
	then
		opts_subnet_mask="${2#*/}"
		shift
	
	elif [ "$1" = "-v" ] || [ "$1" = "-vv" ]
	then
		opts_verbosity=$((opts_verbosity + ${#1} - 1))
	
	elif [ "$1" = "-h" ] || [ "$1" = "--help" ]
	then
		print_usage "$2"
		exit 0
	
	elif [ "${1:0:1}" = "-" ]
	then
		echo "error: Invalid option ($1)."
		print_usage
		exit 1
	else
		if [ -z "$opts_context" ]
		then
			opts_context="$1"
			shift
		fi
		if [ -z "$opts_command" ]
		then
			opts_command="$1"
			shift
		fi
		break # end of options
	fi
	
	if ! shift
	then
		break # no more arguments
	fi
done

if [ "$opts_context" = "wg" ]
then
	[ -z "$1" ] || opts_interface="$1"
	
	conf_file="/etc/wireguard/$opts_interface.conf"
	
	if [ "$opts_command" = "down" ] || [ "$opts_command" = "up" ] || [ "$opts_command" = "update" ]
	then
		
		read -r chain < <(strtoupper "${opts_interface//-/_}_FW")
		chain_allow="${chain}_ALLOW"
		read -r masq_chain < <(strtoupper "${opts_interface//-/_}_PR")
		
		read -r listen_port < <("$0" -i "$opts_interface" conf get-interface ListenPort)
		
		if [ "$opts_command" = "down" ]
		then
			[ -n "$listen_port" ] || read -r listen_port < <("$0" wg show "$opts_interface" listen-port)
			[ -n "$listen_port" ] || listen_port="$WIREGUARD_PORT"
			
			# ignore any failures
			
			# delete link device (which automatically removes all routes relating to this device)
			cmd ip link delete dev "$opts_interface"
			
			# cleanup ip6tables rules after device is removed and down
			cmd ip6tables -D INPUT -p udp --dport "$listen_port" -j ACCEPT
			cmd ip6tables -D INPUT -p tcp --dport "$listen_port" -j ACCEPT
			cmd ip6tables -D INPUT -i "$opts_interface" -j ACCEPT
			cmd ip6tables -D "$chain" -j "$chain_allow"
			cmd ip6tables -F "$chain_allow"
			cmd ip6tables -X "$chain_allow"
			cmd ip6tables -D FORWARD -i "$opts_interface" -j "$chain"
			cmd ip6tables -F "$chain"
			cmd ip6tables -X "$chain"
			cmd ip6tables -t nat -D POSTROUTING -j "$masq_chain"
			cmd ip6tables -t nat -F "$masq_chain"
			cmd ip6tables -t nat -X "$masq_chain"
		
		elif [ "$opts_command" = "up" ] || [ "$opts_command" = "update" ]
		then
			set -e # exit on any failure
			
			if ! [ -e "$conf_file" ]
			then
				echo "error: Configuration file does not exist ($conf_file). Use the 'listen' (on a server) or 'connect' (on a client) command to initialize the Wireguard interface ($opts_interface)."
				exit 1
			fi
			
			wg_confset="syncconf"
		
			if ! [ -e "/sys/class/net/$opts_interface" ]
			then
				# first time set configuration
				wg_confset="setconf"
				
				# ensure default policy of ip6tables is to DROP, unless caught by any filter chain
				cmd ip6tables -P FORWARD DROP
				
				# create link device
				cmd ip link add "$opts_interface" type wireguard
				
				# detect automatically allocated ListenPort
				[ -n "$listen_port" ] || read -r listen_port < <("$0" wg show "$opts_interface" listen-port)
				[ -n "$listen_port" ] || listen_port="$WIREGUARD_PORT"
				
				# apply ip6tables rules before the device is up, but after device is created
				cmd ip6tables -I INPUT -p udp --dport "$listen_port" -j ACCEPT
				cmd ip6tables -I INPUT -p tcp --dport "$listen_port" -j ACCEPT
				cmd ip6tables -I INPUT -i "$opts_interface" -j ACCEPT
				cmd ip6tables -N "$chain"
				cmd ip6tables -A FORWARD -i "$opts_interface" -j "$chain"
				cmd ip6tables -A "$chain" -m state --state INVALID -j DROP
				cmd ip6tables -A "$chain" -m state --state RELATED,ESTABLISHED -j ACCEPT
				cmd ip6tables -N "$chain_allow"
				cmd ip6tables -A "$chain" -j "$chain_allow"
				cmd ip6tables -A "$chain" -j DROP
				cmd ip6tables -t nat -N "$masq_chain"
				cmd ip6tables -t nat -I POSTROUTING 1 -j "$masq_chain"
			fi
			
			# for every server:
			# if ServerEndpoint is defined, resolve it, and apply to Endpoint, done
			# if MeshEndpoint is defined, resolve it, and apply to Endpoint, done
			# if Endpoint is defined, resolve it, and apply to Endpoint, done
			todo_resolved=()
			server_PublicKey=""
			server_Endpoint=""
			server_MeshEndpoint=""
			server_ServerEndpoint=""
			process_server()
			{
				# check if there is a server section to process
				[ -n "$server_PublicKey" ] || return 0
				
				# check if there is an endpoint to resolve
				resolve_host="$server_ServerEndpoint"
				[ -n "$resolve_host" ] || resolve_host="$server_MeshEndpoint"
				[ -n "$resolve_host" ] || resolve_host="$server_Endpoint"
				[ -n "$resolve_host" ] || return 0
				
				resolved_host=""
				case "$resolve_host" in
					\[*\]:*)
						# IPv6 address with port
						resolved_host="$resolve_host"
					;;
					[0-9].[0-9].[0-9].[0-9]:*)
						# IPv4 address with port
						resolved_host="$resolve_host"
					;;
					*:*)
						# hostname with or without port
						read -r resolved_host _ < <(getent hosts "${resolve_host%:*}") || true
						
						if [ -n "$resolved_host" ]
						then
							read -r resolved_host < <(ensure_ipv6_brackets "$resolved_host")
							resolved_host="$resolved_host:${resolve_host##*:}"
						fi
					;;
				esac
				
				if [ -n "$resolved_host" ] && [ "$resolved_host" != "$server_Endpoint" ]
				then
					# resolved host found, and is not the same as the current Endpoint, so update configuration and overwrite Endpoint
					# but since we have a file lock on the configuration right now, we can only do it later on
					todo_resolved+=("$server_PublicKey" "$resolved_host")
				fi
			}
			while read -r line
			do
				# ServerEndpoint, MeshEndpoint, and Endpoint should already contain a port, if the port is not defined, fallback to WIREGUARD_PORT
				
				# if Peer section detected, then it's a new server
				
				if [ "${line:0:1}" = "[" ]
				then
					process_server
					
					server_PublicKey=""
					server_Endpoint=""
					server_MeshEndpoint=""
					server_ServerEndpoint=""
					
					continue
				fi
				
				case "${line// /}" in
					PublicKey=*)
						read -r server_PublicKey <<<"${line#*=}"
					;;
					Endpoint=*)
						read -r server_Endpoint <<<"${line#*=}"
					;;
					MeshEndpoint=*)
						read -r server_MeshEndpoint <<<"${line#*=}"
					;;
					ServerEndpoint=*)
						read -r server_ServerEndpoint <<<"${line#*=}"
					;;
				esac
				
			done < <("$0" -i "$opts_interface" conf list-servers)
			process_server
			
			for ((i=0;i<${#todo_resolved[@]};++i))
			do
				server_PublicKey="${todo_resolved[i]}"
				i=$((i+1))
				server_Endpoint="${todo_resolved[i]}"
				
				echo "info: For Peer[$server_PublicKey] resolved DNS Endpoint to a new address: $server_Endpoint"
				"$0" -i "$opts_interface" conf set-peer "$server_PublicKey" <<EOF
Endpoint = $server_Endpoint
EOF
			done
			
			# only set interface up if "up" command, with "update", don't actually bring the interface up
			if [ "$opts_command" = "up" ]
			then
				# state UP, and configure MTU
				cmd ip link set mtu "$DEFAULT_MTU" up dev "$opts_interface"
			fi
			
			# synchronize configuration with wireguard (use wg-quick if available, for custom rules fallback)
			cmd "$0" wg "$wg_confset" "$opts_interface" <("$0" -i "$opts_interface" conf strip)
			
			# gather prefixes, for ip6tables rules later on
			prefixes=()
			
			
			has_address=false
			
			# add link device addresses
			while read -r address
			do
				[ -n "$address" ] || continue
				
				# Interface-address is currently not supposed to have a metric cost, but it might be in future, so simply trim the cost if it exists
				address="${address%\$*}"
				
				# normalize address
				case "$address" in
					*/*) ;;
					*) address="$address/128"
				esac
				
				# subnet mask is not allowed a link address
				ensure_ip6address "${address%/*}/128" dev "$opts_interface"
				has_address=true
				
				# only add route if it should catch a non-128 mask
				case "$address" in
					*/128|*/) ;;
					*/*)
						# add the route to own Interface address
						ensure_ip6route "$address" dev "$opts_interface" metric "$LOCAL_METRIC"
					;;
				esac
				
				# allow any traffic from this server to anywhere else
				ensure_ip6tables -A "$chain_allow" -s "${address%/*}/128" -j ACCEPT
				
				# allow anyone to access this server
				ensure_ip6tables -A "$chain_allow" -d "${address%/*}/128" -j ACCEPT
				
				# gather prefixes for ip6tables rules later on
				case "$address" in
					*/128) ;;
					*/*)
						# only add if the prefix mask is less than the subnet mask
						prefix_mask="${address#*/}"
						if [ "$prefix_mask" -lt "$opts_subnet_mask" ]
						then
							read -r prefix < <(expand_ipv6 "$address" | tr -d ':')
							prefixes+=("${prefix:0:$(($prefix_mask/4))}")
						fi
					;;
				esac
				
			done < <("$0" -i "$opts_interface" conf get-interface Address)
			
			if ! $has_address
			then
				echo "warning: Device $opts_interface has no virtual IPv6-address assigned. Check [Interface] Address configuration." >&2
			fi
			
			# one IP per line, multiple lines may belong to one peer
			while read -r address
			do
				[ -n "$address" ] || continue
				
				# AllowedIPs may contain cost ($), apply the cost as a metric to the ip -6 route
				relay_cost="0"
				case "$address" in
					*\$) ;;
					*\$*)
						relay_ip="${address%\$*}"
						relay_cost="${address#*\$}"
					;;
				esac
				
				# increase relay cost for once, since this is a server
				relay_cost="$((relay_cost + 1))"
				
				# grab the mask, and ensure any traffic directed at this prefix is routed to the wireguard link
				ensure_ip6route "${address%\$*}" dev "$opts_interface" metric "$((RELAY_METRIC_FACTOR * relay_cost + LOCAL_METRIC))"
				
				# allow any traffic from this server to anywhere else
				ensure_ip6tables -A "$chain_allow" -s "${address%/*}/128" -j ACCEPT
				
				# allow any outgoing traffic to the subnet of the other server, that server will need to check if the incoming traffic is allowed
				ensure_ip6tables -A "$chain_allow" -d "${address%\$*}" -j ACCEPT
				
				# gather prefixes for ip6tables rules later on
				case "$address" in
					*/128) ;;
					*/*)
						# only add if the prefix mask is less than the subnet mask
						prefix_mask="${address#*/}"
						prefix_mask="${prefix_mask%\$*}"
						if [ "$prefix_mask" -lt "$opts_subnet_mask" ]
						then
							read -r prefix < <(expand_ipv6 "${address%\$*}" | tr -d ':')
							prefixes+=("${prefix:0:$(($prefix_mask/4))}")
						fi
					;;
				esac
				
			done < <("$0" -i "$opts_interface" conf list-servers AllowedIPs)
			
			# keep track of groups, and do only one aggregated ip6tables update
			groups=()
			
			# allow anyone to access this incoming client, as long as they are from the same subnet
			while read -r allowed_ip
			do
				[ -n "$allowed_ip" ] || continue
				
				# trim mask, by definition, a client can not have any other mask than 128
				addr="${allowed_ip%/*}"
				
				# expand the address, and remove colons
				read -r addr < <(expand_ipv6 "$addr" | tr -d ':')
				
				# extract the first N digits, i.e. for 48-bit that is 12 digits
				addr="${addr:0:$(($opts_subnet_mask/4))}"
				
				subnet_prefix="$addr"
				
				# insert colons every 4 digits
				read -r addr < <(echo "$addr" | sed -e 's/.\{4\}/&:/g;s/:$//')
				
				# add a mask
				addr="$addr/$opts_subnet_mask"
				
				# recompress expanded IPv6-address (this also adds a trailing ::)
				# local group addr is now a subnet group with its appropriate subnet mask
				read -r local_group_addr < <(compress_ipv6 "$addr")
				
				# we only need to check incoming traffic, outgoing traffic is already allowed per server
				# allow incoming traffic of the same subnet group, but from all different servers (including this server itself)
				for prefix in "${prefixes[@]}"
				do
					# replace addr with prefix, prefix is already limited to its mask, and expanded IPv6 without colons, and only is added to prefixes iff the prefix mask is less than the subnet mask
					
					# compress_ipv6 also adds :: at the end, and preserves mask
					read -r group_addr < <(compress_ipv6 "$prefix${subnet_prefix:${#prefix}}/$opts_subnet_mask")
					
					# allow where: group_addr is the source, local_group_addr is the destination
					groups+=("$group_addr" "$local_group_addr")
				done
				
			done < <("$0" -i "$opts_interface" conf list-clients AllowedIPs)
			
			if [ "${#groups[@]}" -ne 0 ]
			then
				# create rules, but only if not exists yet in ip6tables-save
				printf -- "-A $chain_allow -s %s -d %s -o $opts_interface -j ACCEPT\n" "${groups[@]}" | sort | uniq | grep -v -x -F -f <(ip6tables-save) | while read -r rule
				do
					cmd ip6tables $rule
				done
			fi
			
	#	# if masquerading is allowed
	#	if [ -e "$opts_masq_interface" ]
	#	then
	#		# allow traffic from the masq interface back into the tunnel
	#		cmd ip6tables -A "$chain_allow" -i "$opts_masq_interface" -o "$opts_interface" -j ACCEPT
	#		
	#		# for every Peer for which MASQUERADE is allowed, do:
	#		# prepend prefix + subnet if starts with a single colon
	#		case "$client_addr" in
	#			::*) ;;
	#			:*) client_addr="$opts_vpn_prefix$opts_vpn_subnet$client_addr"
	#		esac
	#		
	#		# masquerade any traffic in the POSTROUTING chain from this address to any non-'virtual network' to the given interface
	#		ensure_ip6tables -t nat -A $masq_chain -s "$client_addr" -d ! "$opts_vpn_prefix::$prefix_mask" -o "$opts_masq_interface" -j MASQUERADE
	#
	#		# specifically allow any traffic from the wireguard tunnel from that address, to be accepted into the target interface
	#		ensure_ip6tables -A $chain_allow -i "$opts_interface" -s "$client_addr" -o "$opts_masq_interface" -j ACCEPT
	#
	#		# any other traffic that was not matched will automatically be dropped, unless whitelisted by $chain_allow
	#	fi
			
			# clients must always be part of a subnet of a server, so no routing rules required for those
			# because the server should already have a mask
			
			# enable IPv6 forwarding
			cmd sysctl net.ipv6.conf.all.accept_ra=2
			cmd sysctl net.ipv6.conf.all.forwarding=1
			
			"$0" wg show "$opts_interface"
			
			echo "info: Success"
		fi
		
	else
		cmd=(wg)
		if [ -n "$opts_command" ]; then cmd+=("$opts_command"); fi
		if [ "$#" -gt 0 ]; then cmd+=("$@"); fi
		exec "${cmd[@]}"
	fi

elif [ "$opts_context" = "conf" ]
then
	conf_file="/etc/wireguard/$opts_interface.conf"
	
	if [ "$opts_command" = "has-address" ]
	then
		# usage note: address must be a single and compressed IPv6 address
		
		# remove comments from conf_file, and then check if the address exists in ANY section in ANY key
		# TODO: make this more strict, only check Address and AllowedIPs entries in Interface and Peer sections respectively
		
		if grep -qE '(,|\s|=)'"$1"'([/$],|\s|$)' <(sed -r -e 's/#.*$//g' <"$conf_file")
		then
			exit 0
		else
			exit 1
		fi
	fi
	
	set -e # exit on any failure
	
	reset_section_values()
	{
		interface_PrivateKey=""
		interface_Address=()
		interface_ListenPort=""
		interface_ServerEndpoint=""
		interface_MeshEndpoint=""
		interface_InterfaceID=""
		interface_SubnetMask=""
		
		peer_PublicKey=""
		peer_Endpoint=""
		peer_AllowedIPs=()
		peer_PersistentKeepalive=""
		peer_Type=""
		peer_ServerEndpoint=""
		peer_MeshEndpoint=""
		
		section_buffer=()
		section=""
	}
	print_section_buffer()
	{
		if [ "$section" = "Interface" ]
		then
			echo "[Interface]"
			
			[ -z "$interface_PrivateKey" ] || echo "PrivateKey = $interface_PrivateKey"
			if [ "${#interface_Address[@]}" -gt 0 ]
			then
				for address in "${interface_Address[@]}"
				do
					echo "Address = $address"
				done
			fi
			[ -z "$interface_ListenPort" ] || echo "ListenPort = $interface_ListenPort"
			[ -z "$interface_ServerEndpoint" ] || echo "ServerEndpoint = $interface_ServerEndpoint"
			[ -z "$interface_MeshEndpoint" ] || echo "MeshEndpoint = $interface_MeshEndpoint"
			[ -z "$interface_InterfaceID" ] || echo "InterfaceID = $interface_InterfaceID"
			[ -z "$interface_SubnetMask" ] || echo "SubnetMask = $interface_SubnetMask"
			
		elif [ "$section" = "Peer" ]
		then
			if [ -z "$peer_PublicKey" ]
			then
				# if no public key, delete whole Peer-section, because the main identifier of this Peer would be gone
				return 1
			fi
			
			echo "[Peer]"
			[ -z "$peer_Type" ] || echo "Type = $peer_Type"
			[ -z "$peer_PublicKey" ] || echo "PublicKey = $peer_PublicKey"
			[ -z "$peer_Endpoint" ] || echo "Endpoint = $peer_Endpoint"
			if [ "${#peer_AllowedIPs[@]}" -gt 0 ]
			then
				for allowed_ip in "${peer_AllowedIPs[@]}"
				do
					echo "AllowedIPs = $allowed_ip"
				done
			fi
			[ -z "$peer_PersistentKeepalive" ] || echo "PersistentKeepalive = $peer_PersistentKeepalive"
			[ -z "$peer_ServerEndpoint" ] || echo "ServerEndpoint = $peer_ServerEndpoint"
			[ -z "$peer_MeshEndpoint" ] || echo "MeshEndpoint = $peer_MeshEndpoint"
		fi
		
		if [ "${#section_buffer[@]}" -gt 0 ]
		then
			for section_line in "${section_buffer[@]}"
			do
				echo "$section_line"
			done
		fi
		
		echo
	}
	peer_is_server()
	{
		if [ "$peer_Type" = "server" ] || [ -n "$peer_Endpoint" ] || [ -n "$peer_ServerEndpoint" ] || [ -n "$peer_MeshEndpoint" ]
		then
			return 0
		fi
		if [ "${#peer_AllowedIPs[@]}" -gt 0 ]
		then
			for allowed_ip in "${peer_AllowedIPs[@]}"
			do
				# if at least one virtual address exists that has a bitmask that is not 128
				# then it is also considered a server (even when no Endpoint has been assigned yet)
				# since maybe this server is only authorized, but has yet to connect
				case "$allowed_ip" in
					*/128) ;;
					*/*) return 0
				esac
			done
		fi
		return 1
	}
	process_section()
	{
		print_section_buffer
	}
	process_eof()
	{
		echo -n # nothing to add
	}
	
	if [ "$opts_command" = "strip" ]
	then
		# print Interface-section
		"$0" -i "$opts_interface" conf get-interface | sed -r -n -e '/^\s*(\[Interface\]|(PrivateKey|ListenPort|FwMark)\s*=)/p'
		
		# print all Peer-sections (and strip $cost metric from every IP in AllowedIPs)
		"$0" -i "$opts_interface" conf list-peers | sed -r -n -e '/^\s*AllowedIPs\s*=/ s/[$][0-9]+//g' -e '/^\s*(\[Peer\]|(PublicKey|PresharedKey|AllowedIPs|Endpoint|PersistentKeepalive)\s*=)/p'
		
		exit 0
	
	elif [ "$opts_command" = "list-peers" ] || [ "$opts_command" = "list-servers" ] || [ "$opts_command" = "list-clients" ]
	then
		process_section()
		{
			if [ "$section" != "Peer" ] || [ -z "$peer_PublicKey" ]
			then
				return 0
			fi
			
			if [ "$opts_command" = "list-servers" ] || [ "$opts_command" = "list-clients" ]
			then
				# a server is defined by either having an Endpoint, or having an AllowedIPs bitmask < 128
				if peer_is_server
				then
					if [ "$opts_command" != "list-servers" ]
					then
						return 0
					fi
					
				else # is client
					
					if [ "$opts_command" != "list-clients" ]
					then
						return 0
					fi
				fi
			fi
			
			if [ "$1" = "PublicKey" ]
			then
				[ -z "$peer_PublicKey" ] || echo "$peer_PublicKey"
				
			elif [ "$1" = "AllowedIPs" ]
			then
				for allowed_ip in "${peer_AllowedIPs[@]}"
				do
					echo "$allowed_ip"
				done
			
			elif [ "$1" = "Endpoint" ]
			then
				# the IPv6-address we chose
				[ -z "$peer_Endpoint" ] || echo "$peer_Endpoint"
			
			elif [ "$1" = "ServerEndpoint" ]
			then
				# the DNS-record the server supplied for its own node
				[ -z "$peer_ServerEndpoint" ] || echo "$peer_ServerEndpoint"
				
			elif [ "$1" = "MeshEndpoint" ]
			then
				# the DNS-record the server supplied for its mesh network
				[ -z "$peer_MeshEndpoint" ] || echo "$peer_MeshEndpoint"
				
			elif [ -n "$1" ]
			then
				return 1
				
			else
				print_section_buffer
			fi
		}
	
	elif [ "$opts_command" = "get-interface" ]
	then
		section_matched=false
		
		process_section()
		{
			if [ "$section" = "Interface" ]
			then
				section_matched=true
				
				if [ "$1" = "Address" ]
				then
					for address in "${interface_Address[@]}"
					do
						echo "$address"
					done

				elif [ "$1" = "PrivateKey" ]
				then
					[ -z "$interface_PrivateKey" ] || echo "$interface_PrivateKey"

				elif [ "$1" = "ListenPort" ]
				then
					[ -z "$interface_ListenPort" ] || echo "$interface_ListenPort"
				
				elif [ "$1" = "ServerEndpoint" ]
				then
					[ -z "$interface_ServerEndpoint" ] || echo "$interface_ServerEndpoint"
					
				elif [ "$1" = "MeshEndpoint" ]
				then
					[ -z "$interface_MeshEndpoint" ] || echo "$interface_MeshEndpoint"
					
				elif [ "$1" = "InterfaceID" ]
				then
					[ -z "$interface_InterfaceID" ] || echo "$interface_InterfaceID"
					
				elif [ "$1" = "SubnetMask" ]
				then
					[ -z "$interface_SubnetMask" ] || echo "$interface_SubnetMask"
					
				elif [ -n "$1" ]
				then 
					return 1
				else
					print_section_buffer
				fi
			fi
		}
		process_eof()
		{
			if ! $section_matched && [ -z "$1" ]
			then
				# print empty Interface, by default, if non-existing Interface section
				echo "[Interface]"
			fi
		}
		
	elif [ "$opts_command" = "get-peer" ] || [ "$opts_command" = "get-server" ] || [ "$opts_command" = "get-client" ]
	then
		section_matched=false
		
		print_partial_peer()
		{
			if [ "$1" = "PublicKey" ]
			then
				[ -z "$peer_PublicKey" ] || echo echo "$peer_PublicKey"

			elif [ "$1" = "AllowedIPs" ]
			then
				for allowed_ip in "${peer_AllowedIPs[@]}"
				do
					echo "$allowed_ip"
				done
				
			elif [ "$1" = "PersistentKeepalive" ]
			then
				[ -z "$peer_PersistentKeepalive" ] || echo echo "$peer_PersistentKeepalive"
				
			elif [ "$1" = "Endpoint" ]
			then
				[ -z "$peer_Endpoint" ] || echo "$peer_Endpoint"
			
			elif [ "$1" = "ServerEndpoint" ]
			then
				[ -z "$peer_ServerEndpoint" ] || echo "$peer_ServerEndpoint"
				
			elif [ "$1" = "MeshEndpoint" ]
			then
				[ -z "$peer_MeshEndpoint" ] || echo "$peer_MeshEndpoint"
			
			elif [ "$1" = "Type" ]
			then
				[ -z "$peer_Type" ] || echo "$peer_Type"
			elif [ -n "$1" ]
			then
				return 1
			else
				print_section_buffer
			fi
		}
		process_section()
		{
			if [ "$section" = "Peer" ] && [ "$peer_PublicKey" = "$1" ]
			then
				if [ "$opts_command" = "get-peer" ]
				then
					section_matched=true
					print_partial_peer "$2"
					
				elif peer_is_server
				then
					if [ "$opts_command" = "get-server" ]
					then
						section_matched=true
						print_partial_peer "$2"
					fi
				else
					if [ "$opts_command" = "get-client" ]
					then
						section_matched=true
						print_partial_peer "$2"
					fi
				fi
			fi
		}
		process_eof()
		{
			if ! $section_matched
			then
				# return non-zero exit code to indicate no Peer was matched
				exit 1
			fi
		}

	elif [ "$opts_command" = "set-peer" ] || [ "$opts_command" = "set-interface" ] || [ "$opts_command" = "set-client" ] || [ "$opts_command" = "set-server" ]
	then
		section_matched=false
		
		# check usage
		if [ -z "$1" ] && {
			[ "$opts_command" = "set-peer" ] || [ "$opts_command" = "set-client" ] || [ "$opts_command" = "set-server" ]
		}
		then
			echo "error: Invalid usage."
			echo "Usage: $0 conf $opts_command <public-key>"
			exit 1
		fi
		
		process_section()
		{
			# if already matched, just print section
			if $section_matched
			then
				if ! print_section_buffer >&$write_fd
				then
					return $?
				fi
				return 0
			fi
			
			# check if we can match section
			if {
				[ "$section" = "Interface" ] && [ "$opts_command" = "set-interface" ] && [ "$section" = "Interface" ]
			} || {
				[ "$section" = "Peer" ] && {
					[ "$opts_command" = "set-peer" ] || [ "$opts_command" = "set-client" ] || [ "$opts_command" = "set-server" ]
				} && [ "$peer_PublicKey" = "$1" ]
			}
			then
				# read section from stdin, and overwrite values, if empty, it means to delete the value for that key
				# if a key is not explicitly defined, it will always be preserved
				
				# mark matched, otherwise the section is new, and will be appended at the end
				section_matched=true
				
				set_interface_Address=false
				new_interface_Address=()
				
				set_peer_Type=false
				set_peer_Endpoint=false
				set_peer_AllowedIPs=false
				set_peer_PersistentKeepalive=false
				new_peer_Type=""
				new_peer_Endpoint=""
				new_peer_ServerEndpoint=""
				new_peer_MeshEndpoint=""
				new_peer_AllowedIPs=()
				new_peer_PersistentKeepalive=""
				
				# you can use stdin or cli-args to set key&value pairs, but these methods cannot be mixed (enforce strict style consistency, to avoid bugs due to using undefined behavior if they are mixed and the implementation changes)
				if [ "$#" -gt 1 ]
				then
					# now read from args[1...] KeyHere=Value or key-here value styles are both supported
					key=""
					for arg in "${@:1}"
					do
						store_value=false
						
						case "$arg" in
							*=*)
								key="${arg%%=*}"
								value="${arg#*=}"
								store_value=true
							;;
							*)
								if [ -z "$key" ]
								then
									key="$arg"
								else
									value="$arg"
									store_value=true
								fi
							;;
						esac
						
						if $store_value
						then
							read -r key < <(strtolower "${key//-/}")
							
							case "$section" in
								Interface)
									case "$key" in
										privatekey)
											read -r interface_PrivateKey <<<"$value"
										;;
										address)
											set_interface_Address=true
											while read -d ',' -r stdin_subline
											do
												read -r stdin_subline <<<"$stdin_subline"
												if [ -n "$stdin_subline" ]
												then
													new_interface_Address+=("$stdin_subline")
												fi
											done <<<"$value,"
										;;
										listenport)
											read -r interface_ListenPort <<<"$value"
										;;
										serverendpoint)
											read -r interface_ServerEndpoint <<<"$value"
										;;
										meshendpoint)
											read -r interface_MeshEndpoint <<<"$value"
										;;
										interfaceid)
											read -r interface_InterfaceID <<<"$value"
										;;
										subnetmask)
											read -r interface_SubnetMask <<<"$value"
										;;
									esac
								;;
								Peer)
									# note, PublicKey cannot be overwritten, since it's already used for matching
									# if it is possible to change the PublicKey, then uniqueness of PublicKey's is not guaranteed
									case "$key" in
										type)
											set_peer_Type=true
											read -r new_peer_Type < <(strtolower "$value")
										;;
										endpoint)
											set_peer_Endpoint=true
											read -r new_peer_Endpoint <<<"$value"
										;;
										serverendpoint)
											set_peer_ServerEndpoint=true
											read -r new_peer_ServerEndpoint <<<"$value"
										;;
										meshendpoint)
											set_peer_MeshEndpoint=true
											read -r new_peer_MeshEndpoint <<<"$value"
										;;
										allowedips)
											set_peer_AllowedIPs=true
											while read -d ',' -r stdin_subline
											do
												read -r stdin_subline <<<"$stdin_subline"
												if [ -n "$stdin_subline" ]
												then
													new_peer_AllowedIPs+=("$stdin_subline")
												fi
											done <<<"$value,"
										;;
										persistentkeepalive)
											set_peer_PersistentKeepalive=true
											read -r new_peer_PersistentKeepalive <<<"$value"
										;;
									esac
								;;
							esac
						fi
					done
				else
					# assume default section is correct
					stdin_section="$section"
					while read -r stdin_line
					do
						if [ -n "$stdin_line" ] && [ "${stdin_line:0:1}" = "[" ]
						then
							stdin_section="${stdin_line%%]*}"
							stdin_section="${stdin_section##*[}"
						fi
						
						# only handle of the current section, so if a section is defined, it must match the section were trying to set
						[ "$stdin_section" = "$section" ] || continue
						
						case "$stdin_section" in
							Interface)
								case "${stdin_line// /}" in
									PrivateKey=*)
										read -r interface_PrivateKey <<<"${stdin_line#*=}"
									;;
									Address=*)
										set_interface_Address=true
										while read -d ',' -r stdin_subline
										do
											read -r stdin_subline <<<"$stdin_subline"
											if [ -n "$stdin_subline" ]
											then
												new_interface_Address+=("$stdin_subline")
											fi
										done <<<"${stdin_line#*=},"
									;;
									ListenPort=*)
										read -r interface_ListenPort <<<"${stdin_line#*=}"
									;;
									ServerEndpoint=*)
										read -r interface_ServerEndpoint <<<"${stdin_line#*=}"
									;;
									MeshEndpoint=*)
										read -r interface_MeshEndpoint <<<"${stdin_line#*=}"
									;;
									InterfaceID=*)
										read -r interface_InterfaceID <<<"${stdin_line#*=}"
									;;
									SubnetMask=*)
										read -r interface_SubnetMask <<<"${stdin_line#*=}"
									;;
								esac
							;;
							Peer)
								# note, PublicKey cannot be overwritten, since it's already used for matching
								# if it is possible to change the PublicKey, then uniqueness of PublicKey's is not guaranteed
								case "${stdin_line// /}" in
									Type=*)
										set_peer_Type=true
										read -r new_peer_Type < <(strtolower "${stdin_line#*=}")
									;;
									Endpoint=*)
										set_peer_Endpoint=true
										read -r new_peer_Endpoint <<<"${stdin_line#*=}"
									;;
									ServerEndpoint=*)
										set_peer_ServerEndpoint=true
										read -r new_peer_ServerEndpoint <<<"${stdin_line#*=}"
									;;
									MeshEndpoint=*)
										set_peer_MeshEndpoint=true
										read -r new_peer_MeshEndpoint <<<"${stdin_line#*=}"
									;;
									AllowedIPs=*)
										set_peer_AllowedIPs=true
										while read -d ',' -r stdin_subline
										do
											read -r stdin_subline <<<"$stdin_subline"
											if [ -n "$stdin_subline" ]
											then
												new_peer_AllowedIPs+=("$stdin_subline")
											fi
										done <<<"${stdin_line#*=},"
									;;
									PersistentKeepalive=*)
										set_peer_PersistentKeepalive=true
										read -r new_peer_PersistentKeepalive <<<"${stdin_line#*=}"
									;;
								esac
							;;
						esac
					done # READ FROM STDIN
				fi
				
				# apply type from cli:
				if ! $set_peer_Type
				then
					if [ "$opts_command" = "set-server" ]
					then
						set_peer_Type=true
						new_peer_Type="server"
					elif [ "$opts_command" = "set-client" ]
					then
						set_peer_Type=true
						new_peer_Type="client"
					fi
				fi
				
				# apply new Interface entries
				if $set_interface_Address
				then
					interface_Address=("${new_interface_Address[@]}")
				fi
				
				# apply new Peer entries with certain restrictions
				if $set_peer_Type && [ "$new_peer_Type" != "$peer_Type" ]
				then
					if [ "$new_peer_Type" = "client" ]
					then
						# remove Endpoints (a client cannot be reached externally per our definition)
						peer_Endpoint=""
						peer_ServerEndpoint=""
						peer_MeshEndpoint=""
						# remove any non-128-bitmask addresses
						if ! $set_peer_AllowedIPs
						then
							set_peer_AllowedIPs=true
							new_peer_AllowedIPs=()
							for allowed_ip in "${peer_AllowedIPs[@]}"
							do
								allowed_ip="${allowed_ip%/128}"
								case "$allowed_ip" in
									*/*|*\$[1-9]*) ;; # skip non-128 bitmasks, and addresses with a non-zero cost
									*)
										new_peer_AllowedIPs+=("$allowed_ip/128")
									;;
								esac
							done
						fi
						# remove persistent keepalive as well
						peer_PersistentKeepalive=""
					fi
					
					peer_Type="$new_peer_Type"
				fi
				if $set_peer_Endpoint
				then
					if [ "$peer_Type" = "client" ] && [ -n "$new_peer_Endpoint" ]
					then
						echo "warning: Endpoint not allowed for [Peer] Type = client." >&2
					else
						peer_Endpoint="$new_peer_Endpoint"
					fi
				fi
				if $set_peer_ServerEndpoint
				then
					if [ "$peer_Type" = "client" ] && [ -n "$new_peer_ServerEndpoint" ]
					then
						echo "warning: Endpoint not allowed for [Peer] Type = client." >&2
					else
						peer_ServerEndpoint="$new_peer_ServerEndpoint"
					fi
				fi
				if $set_peer_MeshEndpoint
				then
					if [ "$peer_Type" = "client" ] && [ -n "$new_peer_MeshEndpoint" ]
					then
						echo "warning: Endpoint not allowed for [Peer] Type = client." >&2
					else
						peer_MeshEndpoint="$new_peer_MeshEndpoint"
					fi
				fi
				if $set_peer_AllowedIPs
				then
					peer_AllowedIPs=("${new_peer_AllowedIPs[@]}")
				fi
				if $set_peer_PersistentKeepalive
				then
					if [ "$peer_Type" = "client" ] && [ -n "$new_peer_PersistentKeepalive" ]
					then
						echo "warning: PersistentKeepalive not allowed for [Peer] Type = client."
					else
						peer_PersistentKeepalive="$new_peer_PersistentKeepalive"
					fi
				fi
			fi
			
			print_section_buffer >&$write_fd
		}
		process_eof()
		{
			# if not matched, append new section at the end of the file
			if ! $section_matched
			then
				case "$opts_command" in
					set-interface) section="Interface" ;;
					set-peer)
						section="Peer"
						peer_PublicKey="$1"
					;;
					set-client)
						section="Peer"
						peer_PublicKey="$1"
						peer_Type="client"
					;;
					set-server)
						section="Peer"
						peer_PublicKey="$1"
						peer_Type="server"
					;;
				esac
				
				process_section "$@"
			fi
		}
		
	elif [ "$opts_command" = "remove-peer" ]
	then
		process_section()
		{
			if [ "$section" = "Peer" ] && [ "$peer_PublicKey" = "$1" ]
			then
				return 0
			else
				print_section_buffer >&$write_fd
			fi
		}

	elif [ "${opts_command:-show}" != "show" ]
	then
		echo "error: Invalid conf command ($opts_command)."
		exit 1
	fi
	
	# ensure existence of conf_file
	(
		umask 077
		touch "$conf_file" || exit 1
	) || exit $?
	
	write_fd=""
	read_fd="200"
	(
		flock -w 10 -e 200 || { echo "error: Failed to flock file ($conf_file)."; exit 1; }
		
		# enable writing, but then read from a swap-file
		# do not write to swap file, because conf-file is already locked, moving swap-file on top of conf-file breaks the flock functionality
		case "$opts_command" in
			set-*|remove-*)
				swap_file="$conf_file.swp"
				cp "$conf_file" "$swap_file"
				
				read_fd=201
				exec 201<"$swap_file" # open for reading

				write_fd=202
				exec 202>"$conf_file" # open for writing, immediately truncates file
		esac
		
		reset_section_values
		
		exitcode=0
		
		while read -r -u "$read_fd" original_line
		do
			# skip empty lines
			if [ -z "$original_line" ]
			then
				continue
			fi
			
			# skip comments, write where needed
			if [ "${original_line:0:1}" = "#" ]
			then
				section_buffer+=("$original_line")
				continue
			fi
			
			# update section
			if [ "${original_line:0:1}" = "[" ]
			then
				process_section "$@" || exitcode=$?
				
				reset_section_values
				
				section="${original_line%%]*}"
				section="${section##*[}"
				
				continue
			fi
			
			# strip comments at end of lines
			line="${original_line%%#*}"
			
			# try to parse line
			parsed=false
			case "$section" in
				Interface)
					case "${line// /}" in
						PrivateKey=*)
							parsed=true
							read -r interface_PrivateKey <<<"${line#*=}"
						;;
						Address=*)
							parsed=true
							while read -d ',' -r subline
							do
								read -r subline <<<"$subline"
								if [ -n "$subline" ]
								then
									interface_Address+=("$subline")
								fi
							done <<<"${line#*=},"
						;;
						ListenPort=*)
							parsed=true
							read -r interface_ListenPort <<<"${line#*=}"
						;;
						ServerEndpoint=*)
							parsed=true
							read -r interface_ServerEndpoint <<<"${line#*=}"
						;;
						MeshEndpoint=*)
							parsed=true
							read -r interface_MeshEndpoint <<<"${line#*=}"
						;;
						InterfaceID=*)
							parsed=true
							read -r interface_InterfaceID <<<"${line#*=}"
						;;
						SubnetMask=*)
							parsed=true
							read -r interface_SubnetMask <<<"${line#*=}"
						;;
					esac
				;;
				Peer)
					case "${line// /}" in
						Type=*)
							parsed=true
							read -r peer_Type < <(strtolower "${line#*=}")
						;;
						PublicKey=*)
							parsed=true
							read -r peer_PublicKey <<<"${line#*=}"
						;;
						Endpoint=*)
							parsed=true
							read -r peer_Endpoint <<<"${line#*=}"
						;;
						ServerEndpoint=*)
							parsed=true
							read -r peer_ServerEndpoint <<<"${line#*=}"
						;;
						MeshEndpoint=*)
							parsed=true
							read -r peer_MeshEndpoint <<<"${line#*=}"
						;;
						AllowedIPs=*)
							parsed=true
							while read -d ',' -r subline
							do
								read -r subline <<<"$subline"
								if [ -n "$subline" ]
								then
									peer_AllowedIPs+=("$subline")
								fi
							done <<<"${line#*=},"
						;;
						PersistentKeepalive=*)
							parsed=true
							read -r peer_PersistentKeepalive <<<"${line#*=}"
						;;
					esac
				;;
			esac
			
			if ! $parsed
			then
				section_buffer+=("$original_line")
			fi
		done
		
		process_section "$@" || exitcode=$?
		
		reset_section_values
		
		process_eof "$@" || exitcode=$?
		
		if [ -n "$write_fd" ]
		then
			exec 201<&-
			exec 202>&-
			
			# if set- or remove- command, replace configuration file with swap file
			rm -f "$swap_file"
		fi
		
		exit $exitcode
		
	) 200<"$conf_file" || exit $?

elif [ "$opts_context" = "client" ]
then
	conf_file="/etc/wireguard/$opts_interface.conf"
	
	read -r local_PrivateKey < <("$0" -i "$opts_interface" conf get-interface PrivateKey)
	
	# generate new PrivateKey if missing
	if [ -z "$local_PrivateKey" ]
	then
		echo "info: Generating private key..."
		read -r local_PrivateKey < <("$0" wg genkey)
		
		if [ -z "$local_PrivateKey" ]
		then
			echo "error: Failed to generate a private key ($0 wg genkey)."
			exit 1
		fi
		
		echo "info: Missing private key generated."
		
		"$0" -i "$opts_interface" conf set-interface <<EOF
PrivateKey = $local_PrivateKey
EOF
	fi
	
	read -r local_PublicKey < <("$0" wg pubkey <<<"$local_PrivateKey")
	
	if [ "$opts_command" = "connect" ]
	then
		connect_host="$1"
		connect_port="${2:-$WIREGUARD_PORT}"
		
		if [ -n "$opts_mac_address" ] && [ "$opts_mac_address" != "auto" ]
		then
			# set a custom InterfaceID, as per command-line options (it must be hexadecimal)
			
			local_InterfaceId="$opts_mac_address"
			
		else
			# try to read from cache
			read -r local_InterfaceID _ < <("$0" -i "$opts_interface" conf get-interface InterfaceID) || true
			
			# automatically determine MAC-address based on available network links
			if [ -z "$local_InterfaceID" ]
			then
				# try the first default route
				read -r _ _ _ _ default_dev _ < <(ip route show default) # parse: _default _via _address _dev <default_dev> _...
				[ -z "$default_dev" ] || read -r local_InterfaceID _ < <(cat /sys/class/net/"$default_dev"/address 2>/dev/null) || true
				
				# then try any available link
				[ -n "$local_InterfaceID" ] || read -r local_InterfaceID _ < <(cat /sys/class/net/*/address 2>/dev/null) || true
				
				# cache this automatically determined MAC-address for consistent re-use in the future (in case network link is unplugged next reconnect)
				if [ -n "$local_InterfaceID" ]
				then
					if "$0" -i "$opts_interface" conf set-interface <<EOF
InterfaceID = $local_InterfaceID
EOF
					then
						echo "info: InterfaceID ($local_InterfaceID) saved to configuration file."
					else
						echo "warning: Failed to save InterfaceID."
					fi
				else
					echo "error: Failed to "
				fi
			fi
		fi
		
		echo "info: Connecting to $connect_host:$connect_port..."
		
		# resolve connect_host to a single IPv4/IPv6 address (if getent ahostsv6, use awk '$2=="STREAM"{print $1; exit}')
		read -r connect_host _ < <(getent hosts "$connect_host")
		
		# if IPv6, wrap IPv6 in square brackets, unless it is already wrapped
		read -r connect_host < <(ensure_ipv6_brackets "$connect_host")
		
		echo "info: Connecting to resolved address: $connect_host:$connect_port..."
		echo "info: Local public key: $local_PublicKey"
		
		remote_PublicKey=""
		remote_ListenPort=""
		remote_Address=()
		remote_MeshEndpoint=""
		
		client_Address=""
		
		section=""
		while read -r line || { socat_exit_code="$line" && break; }
		do
			sock_receive "$line"
			
			if [ -n "$line" ] && [ "${line:0:1}" = "[" ]
			then
				
				section="${line%%]*}]"
				
			else
				case "${line// /}" in
					\#\[server\]:*)
						# Received server message formatted as a special comment (might be a warning or error): # [server]: <message>
						echo "server:${line#*:}"
					;;
					Error=*)
						read -r remote_err <<<"${line#*=}"
						echo "error: Server responded with error: $remote_err"
						exit 1
					;;
				esac
				
				case "$section" in
					\[Interface\])
						case "${line// /}" in
							PublicKey=*)
								read -r remote_PublicKey <<<"${line#*=}"
							;;
							Address=*)
								while read -d ',' -r subline
								do
									read -r subline <<<"$subline"
									if [ -n "$subline" ]
									then
										remote_Address+=("$subline")
									fi
								done <<<"${line#*=},"
							;;
							ListenPort=*)
								read -r remote_ListenPort <<<"${line#*=}"
							;;
							MeshEndpoint=*)
								read -r remote_MeshEndpoint <<<"${line#*=}"
							;;
						esac
					;;
					\[Peer\])
						case "${line// /}" in
							AllowedIPs=*)
								read -r client_Address <<<"${line#*=}"
							;;
						esac
					;;
				esac
			fi
		done < <(
			socat -t20 - tcp:"$connect_host":"$connect_port" < <(
				sock_send "[Peer]"
				sock_send "Type = client"
				sock_send "PublicKey = $local_PublicKey"
				[ -z "$local_InterfaceID" ] || sock_send "InterfaceID = $local_InterfaceID"
				sock_send ""
			)
			echo -n "$?"
		)
		
		if [ "$socat_exit_code" -ne 0 ]
		then
			echo "error: Connection failure ($socat_exit_code)."
			exit 1
		fi
		
		if [ -z "$client_Address" ]
		then
			echo "error: Did not receive AllowedIPs from server. Is the client ($local_PublicKey) authorized?"
			echo "note: The server may authorize this client using: wg-autoconf server allow '$local_PublicKey'"
			exit 1
		fi
		
		# fix ListenPort
		[ -z "$remote_ListenPort" ] || remote_ListenPort="$connect_port"
		
		# resolve Endpoint from MeshEndpoint if possible
		remote_Endpoint="$connect_host:$remote_ListenPort"
		
		# fix MeshEndpoint to be complete with ListenPort
		if [ -n "$remote_MeshEndpoint" ]
		then
			# add missing square brackets to a loose IPv6 address (without port)
			read -r remote_MeshEndpoint < <(ensure_ipv6_brackets "$remote_MeshEndpoint")
			
			# add missing port argument
			case "$remote_MeshEndpoint" in
				\[*\]) # is ipv6-address
					remote_MeshEndpoint="$remote_MeshEndpoint:$remote_ListenPort"
				;;
				*:*) ;; # is host:port definition
				*)
					remote_MeshEndpoint="$remote_MeshEndpoint:$remote_ListenPort"
				;;
			esac
			
			# if remote_ServerEndpoint is given, try to resolve it, and overwrite connect_host with the endpoint host
			case "$remote_MeshEndpoint" in
				\[*\]:*)
					# IPv6 address with port
					remote_Endpoint="$remote_MeshEndpoint"
				;;
				[0-9].[0-9].[0-9].[0-9]:*)
					# IPv4 address with port
					remote_Endpoint="$remote_MeshEndpoint"
				;;
				*:*)
					# hostname with or without port
					read -r resolved_Endpoint _ < <(getent hosts "${remote_MeshEndpoint%:*}") || true
					[ -z "$resolved_Endpoint" ] || remote_Endpoint="$resolved_Endpoint"
					read -r remote_Endpoint < <(ensure_ipv6_brackets "$remote_Endpoint")
					remote_Endpoint="$remote_Endpoint:$remote_ListenPort"
				;;
			esac
		fi
		
		# combine server_Address to one line:
		read -r remote_AddressLine < <(IFS=','; echo "${remote_Address[*]}")
		remote_AddressLine="${remote_AddressLine//,/, }"
		
		echo "info: Configuration received."
		echo "info: Client address: $client_Address"
		echo "info: Server public key: $remote_PublicKey"
		[ -n "$remote_AddressLine" ] && echo "info: Server WireGuard address: $remote_AddressLine"
		echo "info: Server WireGuard port: $remote_ListenPort"
		
		"$0" -i "$opts_interface" conf set-interface <<EOF
Address = $client_Address
EOF
		"$0" -i "$opts_interface" conf set-server "$remote_PublicKey" <<EOF
AllowedIPs = $remote_AddressLine
Endpoint = $remote_Endpoint
PersistentKeepalive = $opts_persistent_keepalive_s
MeshEndpoint = $remote_MeshEndpoint
EOF
		
		"$0" wg up "$opts_interface"
	else
		echo "error: Invalid client command ($opts_command)." >&2
		exit 1
	fi

elif [ "$opts_context" = "server" ]
then
	
	
	if [ "$opts_command" = "allow" ]
	then
		if ! "$0" -i "$opts_interface" conf set-peer "$@"
		then
			echo "error: Failed to allow peer (conf $conf_cmd)."
			exit 1
		fi
		
		if ! "$0" wg update "$opts_interface"
		then
			echo "error: Failed to allow peer (wg update)."
			exit 1
		fi
		
		echo "info: Peer is now allowed access."
		exit 0
	fi
	
	
	if [ "$opts_command" = "deny" ]
	then
		if ! "$0" -i "$opts_interface" conf remove-peer "$@"
		then
			echo "error: Failed to deny peer (conf remove-peer)."
			exit 1
		fi
		
		if ! "$0" wg update "$opts_interface"
		then
			echo "error: Failed to deny peer (wg update)."
			exit 1
		fi
		
		echo "info: Peer is now denied access."
		exit 0
	fi
	
	
	# grab local_PrivateKey
	local_PrivateKey="$("$0" -i "$opts_interface" conf get-interface PrivateKey)"
	
	# generate new PrivateKey if missing
	if [ -z "$local_PrivateKey" ]
	then
		echo "info: Generating private key..."
		local_PrivateKey="$("$0" wg genkey)"
		
		if [ -z "$local_PrivateKey" ]
		then
			echo "error: Failed to generate a private key ($0 wg genkey)."
			exit 1
		fi
		
		echo "info: Missing private key generated."
		
		"$0" -i "$opts_interface" conf set-interface <<EOF
PrivateKey = $local_PrivateKey
EOF
	fi
	
	
	# grab local_PublicKey (generate from private key)
	local_PublicKey="$("$0" wg pubkey <<<"$local_PrivateKey")"
	
	
	# grab local_Address value and generate local_AddressLine
	local_Address=()
	while read -r address
	do
		local_Address+=("$address")
		
	done < <("$0" -i "$opts_interface" conf get-interface Address)
	
	local_AddressLine=""
	if [ -n "$opts_vpn_address" ] || [ "${#local_Address[@]}" -eq 0 ]
	then
		local_AddressLine="${opts_vpn_address:-$DEFAULT_VPN_ADDRESS}"
		local_Address=()
		while read -d ',' -r addr
		do
			read -r addr <<<"$addr"
			if [ -n "$addr" ]
			then
				local_Address+=("$addr")
			fi
		done <<<"${local_AddressLine#*=},"
		
		echo "info: Updating Address in Interface-section."
		
		"$0" -i "$opts_interface" conf set-interface <<EOF
Address = $local_AddressLine
EOF
	else
		read -r local_AddressLine < <(IFS=','; echo "${local_Address[*]}")
		local_AddressLine="${local_AddressLine//,/, }"
	fi
	
	
	# grab local_ListenPort (and set local_ListenPort_configured)
	read -r local_ListenPort < <("$0" -i "$opts_interface" conf get-interface ListenPort)
	[ -n "$local_ListenPort" ] && local_ListenPort_configured=true || local_ListenPort_configured=false
	[ -n "$local_ListenPort" ] || read -r local_ListenPort < <("$0" wg show "$opts_interface" listen-port)
	[ -n "$local_ListenPort" ] || local_ListenPort="$WIREGUARD_PORT"
	
	
	# grab local_ServerEndpoint
	read -r local_ServerEndpoint < <("$0" -i "$opts_interface" conf get-interface ServerEndpoint)
	
	# fallback to current hostname (this is probably the best default behavior that should not be stored in the configuration file explicitly unless done so manually)
	[ -n "$local_ServerEndpoint" ] || read -r local_ServerEndpoint < <(hostname)
	
	if [ "$opts_command" = "connect" ]
	then
		connect_host="$1"
		connect_port="${2:-$WIREGUARD_PORT}"
		
		echo "info: Connecting to $connect_host:$connect_port..."
		
		# resolve connect_host to a single IPv4/IPv6 address (if getent ahostsv6, use awk '$2=="STREAM"{print $1; exit}')
		read -r connect_host _ < <(getent hosts "$connect_host")
		
		# if IPv6, wrap IPv6 in square brackets, unless it is already wrapped
		read -r connect_host < <(ensure_ipv6_brackets "$connect_host")
		
		echo "info: Connecting to resolved address: $connect_host:$connect_port..."
		
		# determine local address prefixed subnet mask
		local_Address=()
		while read -r address
		do
			local_Address+=("$address")
			
		done < <("$0" -i "$opts_interface" conf get-interface Address)
		
		# add AllowedIPs from servers open for relay to local_Address, but with an increased cost
		
		# one IP per line, multiple lines may belong to one peer
		while read -r address
		do
			[ -n "$address" ] || continue
			
			# AllowedIPs may contain cost ($), apply the cost as a metric to the ip -6 route
			relay_cost="0"
			case "$address" in
				*\$*)
					relay_ip="${address%\$*}"
					relay_cost="${address#*\$}"
					[ -n "$relay_cost" ] || relay_cost="0"
				;;
			esac
			# increase relay cost for once, since this is a server
			relay_cost="$((relay_cost + 1))"
			
			local_Address+=("${address%\$*}\$$relay_cost")
			
		done < <("$0" -i "$opts_interface" conf list-servers AllowedIPs)
		
		read -r local_AddressLine < <(IFS=','; echo "${local_Address[*]}")
		local_AddressLine="${local_AddressLine//,/, }"
		
		# fallback to opts
		if [ -z "$local_Address" ]
		then
			local_Address=("$opts_vpn_address")
		fi
		
		# if ServerEndpoint is set, add port to it, because it is mandatory to have a port in the [Peer]-section that we'll send
		if [ -n "$local_ServerEndpoint" ]
		then
			# add missing square brackets to a loose IPv6 address (without port)
			read -r local_ServerEndpoint < <(ensure_ipv6_brackets "$local_ServerEndpoint")
			
			# add missing port argument (an Endpoint and ServerEndpoint in [Peer] must have a port, however, in the [Interface]-section it should be left out, since ListenPort must be set to the same port anyway)
			case "$local_ServerEndpoint" in
				\[*\]) # is ipv6-address
					local_ServerEndpoint="$local_ServerEndpoint:$local_ListenPort"
				;;
				*:*) ;; # is host:port definition
				*)
					local_ServerEndpoint="$local_ServerEndpoint:$local_ListenPort"
				;;
			esac
		fi
		
		# give PublicKey, telling how to securely connect with us
		# give Endpoint, telling how to reach us
		# give Address, telling which IP-address ranges we are responsible for (using a subnet mask), including metric cost for each relay
		
		remote_PublicKey=""
		remote_Address=()
		remote_ListenPort=""
		remote_ServerEndpoint=""
		
		assigned_Address=()
		
		echo "Going to send section to remote server:"
		echo "[Peer]"
		echo "Type = Server"
		echo "PublicKey = $local_PublicKey"
		echo "Address = $local_AddressLine"
		echo "ServerEndpoint = $local_ServerEndpoint"
		echo ""
		
		echo "Receiving from remote server:"
		section=""
		while read -r line || { socat_exit_code="$line" && break; }
		do
			sock_receive "$line"
			
			if [ -n "$line" ] && [ "${line:0:1}" = "[" ]
			then
				section="${line%%]*}]"
			else
				case "$section" in
					\[Interface\])
						case "${line// /}" in
							\#\[server\]:*)
								# Received server message formatted as a special comment (might be a warning or error): # [server]: <message>
								echo "server:${line#*:}"
							;;
							PublicKey=*)
								read -r remote_PublicKey <<<"${line#*=}"
							;;
							Address=*)
								while read -d ',' -r subline
								do
									read -r subline <<<"$subline"
									if [ -n "$subline" ]
									then
										remote_Address+=("$subline")
									fi
								done <<<"${line#*=},"
							;;
							ListenPort=*)
								read -r remote_ListenPort <<<"${line#*=}"
							;;
							ServerEndpoint=*)
								read -r remote_ServerEndpoint <<<"${line#*=}"
							;;
						esac
					;;
					\[Peer\])
						case "${line// /}" in
							\#\[server\]:*)
								# Received server message formatted as a special comment (might be a warning or error): # [server]: <message>
								echo "server:${line#*:}"
							;;
							AllowedIPs=*)
								split ',' "${line#*=}" assigned_Address
								while read -d ',' -r subline
								do
									read -r subline <<<"$subline"
									[ -n "$subline" ] || continue
									
									assigned_Address+=("$subline")
									
								done <<<"${line#*=},"
							;;
						esac
					;;
				esac
			fi
		done < <(socat -t20 - tcp:"$connect_host":"$connect_port" < <(
				sock_send "[Peer]"
				sock_send "Type = Server"
				sock_send "PublicKey = $local_PublicKey"
				sock_send "Address = $local_AddressLine"
				sock_send "ServerEndpoint = $local_ServerEndpoint"
				sock_send ""
			); echo -n "$?")
		
		echo "END of received lines from remote server."
		
		if [ "$socat_exit_code" -ne 0 ]
		then
			echo "error: Connection failure ($socat_exit_code)."
			exit 1
		fi
		
		assigned_PrimaryAddress="${assigned_Address[0]}"
		assigned_PrimaryAddress="${assigned_PrimaryAddress%/*}/128"
		
		# combine server_Address to one line:
		read -r assigned_AddressLine < <(join ',' "${assigned_Address[@]}")
		assigned_AddressLine="${assigned_AddressLine//,/, }"
		
		if [ -z "$assigned_AddressLine" ]
		then
			echo "error: Did not receive AllowedIPs from remote server. Is the local server ($local_PublicKey) authorized?"
			echo "note: The remote server may authorize this local server using: $0 wg server allow '$local_PublicKey' <<<'Type=server'"
			exit 1
		fi
		
		# filter our own local address from remote address, as it might be contained by remote address since it could be a relay for us
		# this would create a loop, so that is avoided here
		filtered_remote_Address=()
		while read -r address
		do
			filtered_remote_Address+=("$address")
			
		done < <(grep -Fvxf <(join $'\n' "${local_Address[@]}") <(join $'\n' "${remote_Address[@]}"))
		remote_Address=("${filtered_remote_Address[@]}")
		
		remote_PrimaryAddress="${remote_Address[0]}"
		remote_PrimaryAddress="${remote_PrimaryAddress%/*}/128"
		
		# combine server_Address to one line:
		read -r remote_AddressLine < <(IFS=','; echo "${remote_Address[*]}")
		remote_AddressLine="${remote_AddressLine//,/, }"
		
		echo "info: Remote server (PublicKey = $remote_PublicKey) can now reach this local server at: $local_ServerEndpoint"
		echo "info: Received virtual IP-address assignment: $assigned_AddressLine"
		
		# add the server's remote Endpoint as connect_host overwrite, and set as Endpoint fo the new [Peer]-section
		[ -n "$remote_ListenPort" ] || remote_ListenPort="$connect_port"
		
		remote_Endpoint="$connect_host:$remote_ListenPort"
		
		if [ -n "$remote_ServerEndpoint" ]
		then
			# add missing square brackets to a loose IPv6 address (without port)
			read -r remote_ServerEndpoint < <(ensure_ipv6_brackets "$remote_ServerEndpoint")
			
			# add missing port argument
			case "$remote_ServerEndpoint" in
				\[*\]) # is ipv6-address
					remote_ServerEndpoint="$remote_ServerEndpoint:$remote_ListenPort"
				;;
				*:*) ;; # is host:port definition
				*)
					remote_ServerEndpoint="$remote_ServerEndpoint:$remote_ListenPort"
				;;
			esac
			
			# if remote_ServerEndpoint is given, try to resolve it, and overwrite connect_host with the endpoint host
			case "$remote_ServerEndpoint" in
				\[*\]:*)
					# IPv6 address with port
					remote_Endpoint="$remote_ServerEndpoint"
				;;
				[0-9].[0-9].[0-9].[0-9]:*)
					# IPv4 address with port
					remote_Endpoint="$remote_ServerEndpoint"
				;;
				*:*)
					# hostname with or without port
					read -r resolved_Endpoint _ < <(getent hosts "${remote_ServerEndpoint%:*}") || true
					[ -z "$resolved_Endpoint" ] || remote_Endpoint="$resolved_Endpoint"
					read -r remote_Endpoint < <(ensure_ipv6_brackets "$remote_Endpoint")
					remote_Endpoint="$remote_Endpoint:$remote_ListenPort"
				;;
			esac
		fi
		
		if "$0" -i "$opts_interface" conf set-server "$remote_PublicKey" <<EOF
[Peer]
Type = server
AllowedIPs = $remote_AddressLine
Endpoint = $remote_Endpoint
ServerEndpoint = $remote_ServerEndpoint
EOF
		then
			echo "info: Success."
		else
			echo "error: Failed to update configuration ($0 -i $opts_interface conf set-server $remote_PublicKey)."
			exit 1
		fi
		
		"$0" wg up "$opts_interface"
		
		"$0" wg show "$opts_interface"
	
	elif [ "$opts_command" = "listen" ]
	then
		read -r opts_bind_host < <(ensure_ipv6_brackets "$opts_bind_host")
		listen_port="$1"
		
		if [ -n "$listen_port" ] && [ "$listen_port" != "$local_ListenPort" ] || ! $local_ListenPort_configured
		then
			local_ListenPort="${listen_port:-$WIREGUARD_PORT}"
			
			echo "info: Updating ListenPort in Interface-section."
			if "$0" -i "$opts_interface" conf set-interface <<EOF
ListenPort = $local_ListenPort
EOF
			then
				local_ListenPort_configured=true
			fi
		fi
		
		"$0" wg up "$opts_interface"
		
		echo "Listening on $opts_bind_host:$local_ListenPort with public key: $local_PublicKey"
		
		cmd=("$0")
		for ((i=1;i<opts_verbosity;i++))
		do
			cmd+=("-v")
		done
		cmd+=("-i" "'$opts_interface'")
		cmd+=("-k" "$opts_persistent_keepalive_s")
		cmd+=("server" "accept" "'$local_PublicKey'")
		
		tcp_listen="tcp-listen"
		if [ "${opts_bind_host:0:1}" = "[" ]
		then
			tcp_listen="tcp6-listen"
		fi
		
		if ! is_num "$local_ListenPort"
		then
			echo "error: Invalid listen port (ListenPort = $local_ListenPort). Check configuration."
			exit 1
		fi
		
		socat "$tcp_listen":"$local_ListenPort",bind="$opts_bind_host",reuseaddr,fork system:"${cmd[*]}"

	elif [ "$opts_command" = "accept" ]
	then
		local_PublicKey="$1"
		
		[ "$opts_verbosity" -ge 1 ] && echo "info: Remote[]: Connected." >&2
		[ "$opts_verbosity" -ge 1 ] && trap 'echo "info: Remote[$remote_PublicKey]: Disconnected." >&2' EXIT
		
		# peer can send:
		remote_PublicKey=""      # the remote Peer's PublicKey (mandatory)
		remote_Type=""           # remote Type: client or server (optional)
		# in case of client:
		remote_InterfaceID=""    # the MAC-address or some other preferred unique identifier of this client (optional)
		# in case of server:
		remote_Address=()        # how to reach the server directly, and a mask specifying which clients it can also support, and $[0-9]+ for a cost metric for relaying servers (mandatory)
		remote_ServerEndpoint="" # how to reach this server from outside (optional, but sort of mandatory if server, otherwise the connection is only half)
		set_remote_ServerEndpoint=false
		
		while read -r line
		do
			sock_receive "$line"
			
			case "${line// /}" in
				PublicKey=*)
					read -r remote_PublicKey <<<"${line#*=}"
				;;
				Type=*)
					read -r remote_Type < <(strtolower "${line#*=}")
				;;
				InterfaceID=*)
					read -r remote_InterfaceID <<<"${line#*=}"
				;;
				Address=*)
					while read -d ',' -r subline
					do
						read -r subline <<<"$subline"
						if [ -n "$subline" ]
						then
							remote_Address+=("$subline")
						fi
					done <<<"${line#*=},"
				;;
				ServerEndpoint=*)
					set_remote_ServerEndpoint=true
					read -r remote_ServerEndpoint <<<"${line#*=}"
				;;
			esac
			
		done # read from stdin, client must close stdin before server can continue (that is to half-close socket on their end)
		
		if [ -z "$remote_PublicKey" ]
		then
			echo "warn: Remote[$remote_PublicKey]: Bad protocol. PublicKey not given." >&2
			sock_send "# [server]: Unauthorized (no PublicKey received)."
			sock_send "Error = 401 Unauthorized"
			exit 41
		fi
		
		# send information about this server's wireguard configuration to the client socket (stdout):
		sock_send "[Interface]"
		sock_send "PublicKey = $local_PublicKey"
		
		# print ListenPort if it exists (it should exist, otherwise that is a warning, how can a client expect to guess the ListenPort if it is dynamic or unknown)
		[ -z "$local_ListenPort" ] || sock_send "ListenPort = $local_ListenPort"
		
		# grab ServerEndpoint and print if exists (this is the Interface-section, so ServerEndpoint should not have a port)
		[ -z "$local_ServerEndpoint" ] || sock_send "ServerEndpoint = $local_ServerEndpoint"
		
		# grab MeshEndpoint and print if exists, this should be a DNS that resolves to multiple addresses, every one specifying one server in the Mesh network
		# the client should use this over the Endpoint, if it exists, but a server will simply use the Endpoint, because it must have one unique Endpoint for each unique Peer
		read -r local_MeshEndpoint < <("$0" -i "$opts_interface" conf get-interface MeshEndpoint)
		[ -z "$local_MeshEndpoint" ] || sock_send "MeshEndpoint = $local_MeshEndpoint"
		
		# grab the latest known SubnetMask
		read -r local_SubnetMask < <("$0" -i "$opts_interface" conf get-interface SubnetMask)
		
		
		# get peer section
		if ! peer_info="$("$0" -i "$opts_interface" conf get-peer "$remote_PublicKey")"
		then
			# Peer is not authorized
			echo "warn: Remote[$remote_PublicKey]: Not authorized (PublicKey = $remote_PublicKey). To authorize, run: $0 server allow $remote_PublicKey" >&2
			sock_send "# [server]: Forbidden."
			sock_send "Error = 403 Forbidden"
			exit 43
		fi
		
		# parse [Peer]-section from configuration
		peer_Type=""
		peer_AllowedIPs=()
		peer_Endpoint=""
		peer_ServerEndpoint=""
		peer_PersistentKeepalive=""
		
		while read -r line
		do
			# trim comments
			line="${line%%#*}"
			
			case "${line// /}" in
				Type=*)
					read -r peer_Type < <(strtolower "${line#*=}")
				;;
				Endpoint=*)
					read -r peer_Endpoint <<<"${line#*=}"
					
					# autodetected server-type, but don't overwrite if already set
					[ -z "$peer_Endpoint" ] || [ -n "$peer_Type" ] || peer_Type="server"
				;;
				ServerEndpoint=*)
					read -r peer_ServerEndpoint <<<"${line#*=}"
					
					# autodetected server-type, but don't overwrite if already set
					[ -z "$peer_ServerEndpoint" ] || [ -n "$peer_Type" ] || peer_Type="server"
				;;
				AllowedIPs=*)
					while read -d ',' -r subline
					do
						read -r subline <<<"$subline"
						if [ -n "$subline" ]
						then
							# autodetect server-type, but don't overwrite if already set
							case "$subline" in
								*/128) ;;
								*/*) [ -n "$peer_Type" ] || peer_Type="server"
							esac
							
							peer_AllowedIPs+=("$subline")
						fi
					done <<<"${line#*=},"
				;;
				PersistentKeepalive=*)
					read -r peer_PersistentKeepalive <<<"${line#*=}"
				;;
			esac
		done <<<"$peer_info"
		
		if [ "$peer_Type" = "server" ]
		then
			# peer is an authorized server, connecting with us again
			lines=()
			
			# Address was received, and Address differs from AllowedIPs
			if [ "${#remote_Address[@]}" -gt 0 ] && [ "${peer_AllowedIPs[*]}" != "${remote_Address[*]}" ]
			then
				# combine server_Address to one line:
				read -r remote_AddressLine < <(IFS=','; echo "${remote_Address[*]}")
				remote_AddressLine="${remote_AddressLine//,/, }"
				
				lines+=("AllowedIPs = $remote_AddressLine")
			fi
			
			# ServerEndpoint was received, and ServerEndpoint differs from ServerEndpoint
			if $set_remote_ServerEndpoint && [ "$remote_ServerEndpoint" != "$peer_ServerEndpoint" ]
			then
				# the connecting peer is responsible for adding its own ListenPort to the ServerEndpoint address
				lines+=("ServerEndpoint = $remote_ServerEndpoint")
			fi
			
			# Ensure PersistentKeepalive is set to our current options (in case [Peer] will be created for the first time, or configuration was manually changed)
			if [ "$peer_PersistentKeepalive" != "$opts_persistent_keepalive_s" ]
			then
				lines+=("PersistentKeepalive = $opts_persistent_keepalive_s")
			fi
			
			# if any new lines need to be added
			if [ "${#lines[@]}" -gt 0 ]
			then
				# update configuration file
				if "$0" -i "$opts_interface" conf set-server "$remote_PublicKey" < <(
					echo "[Peer]"
					echo "Type = server"
					for line in "${lines[@]}"
					do
						echo "$line"
					done
				) >&2
				then
					# apply new configuration to Wireguard interface
					"$0" wg update "$opts_interface" >&2
				else
					echo "error: Remote[$remote_PublicKey]: Failed to update configuration for Peer ($remote_PublicKey)." >&2
					sock_send "# [server]: 500 Internal Server Error"
					sock_send "Error = 500 Internal Server Error"
					exit 50
				fi
			fi
			
		else
			
			if [ "$remote_Type" = "server" ]
			then
				# this server wants to connect as a server, but it is not allowed as a server here
				# that is an error
				echo "warn: Remote[$remote_PublicKey]: Client wants to connect as a server, but is not authorized as a server. To authorize client as a server, run: $0 server allow $remote_PublicKey <<<Type=server" >&2
				sock_send "# [server]: Forbidden (not authorized as a server)."
				sock_send "Error = 403 Forbidden"
				exit 43
			fi
			
			local_AddressMask=""
			local_AddressPrefix=""
			for address in "${local_Address[@]}"
			do
				case "$address" in
					*/128|*/128\$*|*/) ;;
					*/*)
						# trim cost
						address="${address%\$*}"
						
						local_AddressPrefix="${address%/*}"
						local_AddressMask="${address#*/}"
						
						# apply mask to the prefix to really turn it into a prefix
						read -r local_AddressPrefix < <(expand_ipv6 "$local_AddressPrefix")
						local_AddressPrefix="${local_AddressPrefix//:/}"
						hexdigit_count="$((local_AddressMask / 4))"
						local_AddressPrefix="${local_AddressPrefix:0:$hexdigit_count}"
						read -r local_AddressPrefix < <(sed -e 's/.\{4\}/&:/g;s/:$//' <<<"$local_AddressPrefix")
						read -r local_AddressPrefix < <(compress_ipv6 "$local_AddressPrefix")
						
						break # from for-loop, the first address with server-mask is chosen as prefix/mask
					;;
				esac
			done
			
			if [ -z "$local_AddressMask" ]
			then
				echo "error: Remote[$remote_PublicKey]: Local server is not currently a server (no Address mask has been specified, check configuration)." >&2
				sock_send "# [server]: 503 Service Unavailable (Invalid server configuration)"
				sock_send "Error = 503 Service Unavailable"
				exit 53
			fi
			
			# peer is an authorized client (only the first AllowedIPs is considered)
			client_addr="${peer_AllowedIPs[0]}"
			
			# if client_addr starts with :, then automatically prepend the prefix&subnet
			if [ -n "$client_addr" ] && [ "${client_addr:0:1}" = ":" ]
			then
				# prepend prefix and subnet:
				client_addr="$local_AddressPrefix$client_addr"
				
				# client_addr is allowed to be a partial address ending with a subnet mask, so that client's Interface ID can overwrite that part
			fi
			
			# validate ipv6 address (ip exit code is 1 if parse error)
			if is_ipv6 "$client_addr"
			then
				echo "info: Remote[$remote_PublicKey]: Found statically configured IPv6 address ($client_addr)." >&2
				
				# expand client_addr
				read -r client_addr < <(expand_ipv6 "$client_addr")
			else
				# mark as invalid address
				client_addr=""
			fi
			
			# if the client's Interface ID is provided, and if client_addr ends with a mask (e.g. /64), then overwrite the last digits with the client's Interface ID
			hexdigit_count="32"
			case "$client_addr" in
				*/*)
					client_addr_mask="${client_addr%%*/}"
					
					if is_num "$client_addr_mask"
					then
						hexdigit_count="$((client_addr_mask / 4))"
					fi
				;;
			esac
			
			# Retry using Client's Interface ID if provided
			if [ -n "$remote_InterfaceID" ] && {
					[ -z "$client_addr" ] || [ "$hexdigit_count" -lt 32 ]
				}
			then
				if is_ipv6 "$remote_InterfaceID"
				then
					read -r remote_InterfaceID_hex < <(expand_ipv6 "$remote_InterfaceID")
				else
					# else: could be a MAC-address, or any hexidecimal string
					read -r remote_InterfaceID_hex <<<"$remote_InterfaceID"
				fi
				
				# remove colons (if IPv6 it must already be expanded, so this is safe to do)
				# actually, remove any non-[a-f0-9] character
				read -r remote_InterfaceID_hex < <(strtolower "$(sed -r -e 's/[^0-9a-f]+//gi' <<<"$remote_InterfaceID_hex")")
				
				sock_send "# [server]: Interface hex: $remote_InterfaceID_hex (hexdigit_count: $hexdigit_count based on $client_addr using $local_AddressMask)"
				
				# preserve first $digit_count digits of the client_addr, and substitute the rest with client_interface_id, if a mask was provided for the client
				if [ "$hexdigit_count" -lt 32 ]
				then
					# if hexdigit_count < 32, then client_addr MUST have matched */*, meaning it's not empty, and expanded
					client_addr="${client_addr%/*}"
					# recombine hexdigits up to hexdigit_count, client_addr is already expanded
					client_addr="${client_addr//:/}"
					client_addr="${client_addr:0:$hexdigit_count}$remote_InterfaceID_hex"
				else
					# set client_addr to address prefix
					read -r client_addr < <(expand_ipv6 "$local_AddressPrefix::")
					
					# add client's Interface ID not before the end of AddressPrefix
					client_addr="${client_addr//:/}"
					client_addr_prefix="${client_addr:0:$((local_AddressMask / 4))}"
					offset="${#client_addr_prefix}"
					
					# for security, ensure that offset is not lower than $local_SubnetMask
					subnet_offset="$((local_SubnetMask / 4))"
					if [ "$offset" -lt "$subnet_offset" ]
					then
						offset="$subnet_offset"
					fi
					
					# if the remote Interface ID is not long enough to fill up the zeroes, move offset even more to the right (align to right)
					if [ "${#remote_InterfaceID_hex}" -lt "$((32 - offset))" ]
					then
						offset="$((32 - ${#remote_InterfaceID_hex}))"
					fi
					
					# add remote Interface ID at the given offset
					client_addr="${client_addr:0:$offset}$remote_InterfaceID_hex"
				fi
				
				# limit to 32 digits
				client_addr="${client_addr:0:32}"
				# insert colons every 4 digits, client_addr is currently a hexstring without colons
				read -r client_addr < <(sed -e 's/.\{4\}/&:/g;s/:$//' <<<"$client_addr")
				
				# validate ipv6 address (ip exit code is 1 if parse error)
				if is_ipv6 "$client_addr"
				then
					echo "info: Remote[$remote_PublicKey]: Using IPv6 address ($client_addr) with Interface ID provided by client ($remote_InterfaceID)." >&2
				else
					echo "warning: Remote[$remote_PublicKey]: Interface ID ($remote_InterfaceID) provided by client is invalid ($client_addr)." >&2
					
					# clear the invalid address
					client_addr=""
				fi
			fi
			
			# fallback to automatic iterative IP-address assignment
			if [ -z "$client_addr" ]
			then
				# find unused ipv6 address
				# ::1 is typically reserved for the server's own address, start at 2
				count=2
				client_addr="$local_AddressPrefix::$count"
				
				# the mask might limit clients to an even lower limit than 4 hex-digits
				max_clients="$((2**((128 - $local_AddressMask)/2)))"
				if [ "$max_clients" -gt 65536 ]
				then
					# hard-limit to 65536 clients, otherwise the code to generate client ID's needs to be updated
					max_clients=65536
				fi
				
				# we could also use "$0" conf has-address <Address>, to check for uniqueness
				while [ "$count" -lt "$max_clients" ] && "$0" -i "$opts_interface" conf has-address "$client_addr"
				do
					# add 1 to the last hex group (this method limits the number of clients to a maximum of 65534 clients)
					client_addr="${client_addr%:*}:$(printf '%x' "$((16#${client_addr##*:} + 1))")"
					
					count=$((count + 1))
				done
				
				if [ "$count" -eq "$max_clients" ]
				then
					echo "error: Remote[$remote_PublicKey]: Address space exhausted, too many clients ($count)." >&2
					sock_send "# [server]: 507 Insufficient Storage (Address space exhausted, too many clients)"
					sock_send "Error = 507 Insufficient Storage"
					exit 57
				fi
			fi
			
			# compress client_addr
			read -r client_addr < <(compress_ipv6 "$client_addr")
			
			# check if our client_addr is new/changed:
			if [ "$client_addr" != "${peer_AllowedIPs[0]}" ]
			then
				# check if address is unique:
				if "$0" -i "$opts_interface" conf has-address "$client_addr"
				then
					echo "error: Remote[$remote_PublicKey]: Forbidden address ($client_addr), it already exists in the configuration as an Address or AllowedIPs ($conf_file)." >&2
					sock_send "# [server]: 409 Conflict (Forbidden address: $client_addr, not unique)"
					sock_send "Error = 409 Conflict"
					exit 49
				fi
				
				case "$client_addr" in
					*::|*:0)
						echo "error: Remote[$remote_PublicKey]: Forbidden address ($client_addr), it ends with :: or :0." >&2
						sock_send "# [server]: 409 Conflict (Forbidden address: $client_addr, ends with :: or :0)"
						sock_send "Error = 409 Conflict"
						exit 49
					;;
					"$local_AddressPrefix"*) ;; # this is correct, client_addr should be in the subnet of this server
					*)
						echo "error: Remote[$remote_PublicKey]: Forbidden address ($client_addr), it does not start with the server prefix ($local_AddressPrefix)." >&2
						sock_send "# [server]: 409 Conflict (Forbidden address: $client_addr, bad prefix)"
						sock_send "Error = 409 Conflict"
						exit 49
					;;
				esac
				
				# check if client_addr is unique (must be done by set-peer, for atomic locking purposes)
				if "$0" -i "$opts_interface" conf set-client "$remote_PublicKey" >&2 <<EOF
[Peer]
Type = client
AllowedIPs = $client_addr
EOF
				then
					echo "info: Remote[$remote_PublicKey]: Configuration updated. Peer (PublicKey = $remote_PublicKey) added with virtual IP-address: $client_addr" >&2
					
					# refresh Wireguard configuration
					"$0" wg update "$opts_interface" >&2
				else
					echo "error: Remote[$remote_PublicKey]: Failed to update configuration for Peer ($remote_PublicKey)." >&2
					sock_send "# [server]: 500 Internal Server Error"
					sock_send "Error = 500 Internal Server Error"
					exit 50
				fi
			fi
		fi
		
		# only if client is authorized (and after possible [Peer]-server section has been updated), we show properties about the internals of this virtual network:
		
		# print the local address
		for address in "${local_Address[@]}"
		do
			sock_send "Address = $address"
		done
		
		# here we also want to print every Peer we relay for as our own Address, but with increased cost
		while read -r address
		do
			[ -n "$address" ] || continue
			
			case "$address" in
				*\$*)
					relay_ip="${address%\$*}"
					relay_cost="${address#*\$}"
					
					if [ -z "$relay_cost" ]
					then
						# default relay cost, if no number is indicated at the end, is zero
						relay_cost="0"
					fi
					sock_send "Address = ${relay_ip}\$$((relay_cost + 1))"
				;;
				*)
					sock_send "Address = ${address}\$1"
				;;
			esac
			
		done < <("$0" -i "$opts_interface" conf list-servers AllowedIPs)
		
		# client exists, show all configuration entries of this client:
		# this is mostly useful for the client so that it may read AllowedIPs and set it as its [Interface]'s Address
		# note on security: anyone who knows a client's identifier can discover their IP-address, public key, and potentially other properties
		
		[ "$opts_verbosity" -ge 1 ] && echo "info: Remote[$remote_PublicKey]: Sending Peer-block to remote peer." >&2
		
		while read -r line
		do
			sock_send "$line"
			
		done < <("$0" -i "$opts_interface" conf get-peer "$remote_PublicKey")
	else
		echo "error: Invalid server command ($opts_command)." >&2
		exit 1
	fi
elif [ -z "$opts_context" ]
then
	print_usage
else
	echo "error: Invalid context command ($opts_context)." >&2
	echo "For usage, see: $0 --help" >&2
	exit 1
fi
